'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CHECKBOX_RADIO_TOKEN = exports.RANGE_TOKEN = undefined;
exports.default = model;

var _config = require('core/config');

var _config2 = _interopRequireDefault(_config);

var _helpers = require('compiler/helpers');

var _model = require('compiler/directives/model');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warn = void 0;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.


var RANGE_TOKEN = exports.RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = exports.CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn('<' + el.tag + ' v-model="' + value + '" type="file">:\n' + 'File inputs are read only. Use a v-on:change listener instead.');
    }
  }

  if (el.component) {
    (0, _model.genComponentModel)(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!_config2.default.isReservedTag(tag)) {
    (0, _model.genComponentModel)(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn('<' + el.tag + ' v-model="' + value + '">: ' + 'v-model is not supported on this element type. ' + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = (0, _helpers.getBindingAttr)(el, 'value') || 'null';
  var trueValueBinding = (0, _helpers.getBindingAttr)(el, 'true-value') || 'true';
  var falseValueBinding = (0, _helpers.getBindingAttr)(el, 'false-value') || 'false';
  (0, _helpers.addProp)(el, 'checked', 'Array.isArray(' + value + ')' + ('?_i(' + value + ',' + valueBinding + ')>-1') + (trueValueBinding === 'true' ? ':(' + value + ')' : ':_q(' + value + ',' + trueValueBinding + ')'));
  (0, _helpers.addHandler)(el, 'change', 'var $$a=' + value + ',' + '$$el=$event.target,' + ('$$c=$$el.checked?(' + trueValueBinding + '):(' + falseValueBinding + ');') + 'if(Array.isArray($$a)){' + ('var $$v=' + (number ? '_n(' + valueBinding + ')' : valueBinding) + ',') + '$$i=_i($$a,$$v);' + ('if($$el.checked){$$i<0&&(' + (0, _model.genAssignmentCode)(value, '$$a.concat([$$v])') + ')}') + ('else{$$i>-1&&(' + (0, _model.genAssignmentCode)(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ')}') + ('}else{' + (0, _model.genAssignmentCode)(value, '$$c') + '}'), null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = (0, _helpers.getBindingAttr)(el, 'value') || 'null';
  valueBinding = number ? '_n(' + valueBinding + ')' : valueBinding;
  (0, _helpers.addProp)(el, 'checked', '_q(' + value + ',' + valueBinding + ')');
  (0, _helpers.addHandler)(el, 'change', (0, _model.genAssignmentCode)(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = 'Array.prototype.filter' + '.call($event.target.options,function(o){return o.selected})' + '.map(function(o){var val = "_value" in o ? o._value : o.value;' + ('return ' + (number ? '_n(val)' : 'val') + '})');

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = 'var $$selectedVal = ' + selectedVal + ';';
  code = code + ' ' + (0, _model.genAssignmentCode)(value, assignment);
  (0, _helpers.addHandler)(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (process.env.NODE_ENV !== 'production') {
    var _value = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (_value && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn(binding + '="' + _value + '" conflicts with v-model on the same element ' + 'because the latter already expands to a value binding internally');
    }
  }

  var _ref = modifiers || {},
      lazy = _ref.lazy,
      number = _ref.number,
      trim = _ref.trim;

  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = '$event.target.value.trim()';
  }
  if (number) {
    valueExpression = '_n(' + valueExpression + ')';
  }

  var code = (0, _model.genAssignmentCode)(value, valueExpression);
  if (needCompositionGuard) {
    code = 'if($event.target.composing)return;' + code;
  }

  (0, _helpers.addProp)(el, 'value', '(' + value + ')');
  (0, _helpers.addHandler)(el, event, code, null, true);
  if (trim || number) {
    (0, _helpers.addHandler)(el, 'blur', '$forceUpdate()');
  }
}

