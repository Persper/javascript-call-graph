'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warn = exports.bindRE = exports.forIteratorRE = exports.forAliasRE = exports.dirRE = exports.onRE = undefined;
exports.createASTElement = createASTElement;
exports.parse = parse;
exports.processElement = processElement;
exports.processFor = processFor;
exports.parseFor = parseFor;
exports.addIfCondition = addIfCondition;

var _he = require('he');

var _he2 = _interopRequireDefault(_he);

var _htmlParser = require('./html-parser');

var _textParser = require('./text-parser');

var _filterParser = require('./filter-parser');

var _model = require('../directives/model');

var _util = require('shared/util');

var _env = require('core/util/env');

var _helpers = require('../helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var onRE = exports.onRE = /^@|^v-on:/;
var dirRE = exports.dirRE = /^v-|^@|^:/;
var forAliasRE = exports.forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
var forIteratorRE = exports.forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

var argRE = /:(.*)$/;
var bindRE = exports.bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = (0, _util.cached)(_he2.default.decode);

// configurable state
var warn = exports.warn = void 0;
var delimiters = void 0;
var transforms = void 0;
var preTransforms = void 0;
var postTransforms = void 0;
var platformIsPreTag = void 0;
var platformMustUseProp = void 0;
var platformGetTagNamespace = void 0;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  };
}

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  exports.warn = warn = options.warn || _helpers.baseWarn;

  platformIsPreTag = options.isPreTag || _util.no;
  platformMustUseProp = options.mustUseProp || _util.no;
  platformGetTagNamespace = options.getTagNamespace || _util.no;

  transforms = (0, _helpers.pluckModuleFunction)(options.modules, 'transformNode');
  preTransforms = (0, _helpers.pluckModuleFunction)(options.modules, 'preTransformNode');
  postTransforms = (0, _helpers.pluckModuleFunction)(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root = void 0;
  var currentParent = void 0;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn(msg);
    }
  }

  function closeElement(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  (0, _htmlParser.parseHTML)(template, {
    warn: warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (_env.isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !(0, _env.isServerRendering)()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + ('<' + tag + '>') + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce('Cannot use <' + el.tag + '> as component root element because it may ' + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce('Component template should contain exactly one root element. ' + 'If you are using v-if on multiple elements, ' + 'use v-else-if to chain them instead.');
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var _name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[_name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      closeElement(element);
    },
    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce('text "' + text + '" outside root element will be ignored.');
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (_env.isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var res = void 0;
        if (!inVPre && text !== ' ' && (res = (0, _textParser.parseText)(text, delimiters))) {
          children.push({
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment(text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root;
}

function processPre(el) {
  if ((0, _helpers.getAndRemoveAttr)(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey(el) {
  var exp = (0, _helpers.getBindingAttr)(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn('<template> cannot be keyed. Place the key on real elements instead.');
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = (0, _helpers.getBindingAttr)(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp = void 0;
  if (exp = (0, _helpers.getAndRemoveAttr)(el, 'v-for')) {
    var res = parseFor(exp);
    if (res) {
      (0, _util.extend)(el, res);
    } else if (process.env.NODE_ENV !== 'production') {
      warn('Invalid v-for expression: ' + exp);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '');
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res;
}

function processIf(el) {
  var exp = (0, _helpers.getAndRemoveAttr)(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if ((0, _helpers.getAndRemoveAttr)(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = (0, _helpers.getAndRemoveAttr)(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn('v-' + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + ' ' + ('used on element <' + el.tag + '> without corresponding v-if.'));
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn('text "' + children[i].text.trim() + '" between v-if and v-else(-if) ' + 'will be ignored.');
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once = (0, _helpers.getAndRemoveAttr)(el, 'v-once');
  if (once != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = (0, _helpers.getBindingAttr)(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn('`key` does not work on <slot> because slots are abstract outlets ' + 'and can possibly expand into multiple elements. ' + 'Use the key on a wrapping element instead.');
    }
  } else {
    var slotScope = void 0;
    if (el.tag === 'template') {
      slotScope = (0, _helpers.getAndRemoveAttr)(el, 'scope');
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && slotScope) {
        warn('the "scope" attribute for scoped slots have been deprecated and ' + 'replaced by "slot-scope" since 2.5. The new "slot-scope" attribute ' + 'can also be used on plain elements in addition to <template> to ' + 'denote scoped slots.', true);
      }
      el.slotScope = slotScope || (0, _helpers.getAndRemoveAttr)(el, 'slot-scope');
    } else if (slotScope = (0, _helpers.getAndRemoveAttr)(el, 'slot-scope')) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {
        warn('Ambiguous combined usage of slot-scope and v-for on <' + el.tag + '> ' + '(v-for takes higher priority). Use a wrapper <template> for the ' + 'scoped slot to make it clearer.', true);
      }
      el.slotScope = slotScope;
    }
    var slotTarget = (0, _helpers.getBindingAttr)(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        (0, _helpers.addAttr)(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent(el) {
  var binding = void 0;
  if (binding = (0, _helpers.getBindingAttr)(el, 'is')) {
    el.component = binding;
  }
  if ((0, _helpers.getAndRemoveAttr)(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i = void 0,
      l = void 0,
      name = void 0,
      rawName = void 0,
      value = void 0,
      modifiers = void 0,
      isProp = void 0;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = (0, _filterParser.parseFilters)(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = (0, _util.camelize)(name);
            if (name === 'innerHtml') name = 'innerHTML';
          }
          if (modifiers.camel) {
            name = (0, _util.camelize)(name);
          }
          if (modifiers.sync) {
            (0, _helpers.addHandler)(el, 'update:' + (0, _util.camelize)(name), (0, _model.genAssignmentCode)(value, '$event'));
          }
        }
        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          (0, _helpers.addProp)(el, name, value);
        } else {
          (0, _helpers.addAttr)(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        (0, _helpers.addHandler)(el, name, value, modifiers, false, warn);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        (0, _helpers.addDirective)(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var res = (0, _textParser.parseText)(value, delimiters);
        if (res) {
          warn(name + '="' + value + '": ' + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      (0, _helpers.addAttr)(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        (0, _helpers.addProp)(el, name, 'true');
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !_env.isIE && !_env.isEdge) {
      warn('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn('<' + el.tag + ' v-model="' + value + '">: ' + 'You are binding v-model directly to a v-for iteration alias. ' + 'This will not be able to modify the v-for source array because ' + 'writing to the alias is like modifying a function local variable. ' + 'Consider using an array of objects and use v-model on an object property instead.');
    }
    _el = _el.parent;
  }
}

