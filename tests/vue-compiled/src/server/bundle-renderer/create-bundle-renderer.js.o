'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.createBundleRendererCreator = createBundleRendererCreator;

var _util = require('../util');

var _createBundleRunner = require('./create-bundle-runner');

var _sourceMapSupport = require('./source-map-support');

var fs = require('fs');
var path = require('path');
var PassThrough = require('stream').PassThrough;

var INVALID_MSG = 'Invalid server-rendering bundle format. Should be a string ' + 'or a bundle Object of type:\n\n' + '{\n  entry: string;\n  files: { [filename: string]: string; };\n  maps: { [filename: string]: string; };\n}\n';

// The render bundle can either be a string (single bundled file)
// or a bundle manifest object generated by vue-ssr-webpack-plugin.
function createBundleRendererCreator(createRenderer) {
  return function createBundleRenderer(bundle) {
    var rendererOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var files = void 0,
        entry = void 0,
        maps = void 0;
    var basedir = rendererOptions.basedir;

    // load bundle if given filepath
    if (typeof bundle === 'string' && /\.js(on)?$/.test(bundle) && path.isAbsolute(bundle)) {
      if (fs.existsSync(bundle)) {
        var isJSON = /\.json$/.test(bundle);
        basedir = basedir || path.dirname(bundle);
        bundle = fs.readFileSync(bundle, 'utf-8');
        if (isJSON) {
          try {
            bundle = JSON.parse(bundle);
          } catch (e) {
            throw new Error('Invalid JSON bundle file: ' + bundle);
          }
        }
      } else {
        throw new Error('Cannot locate bundle file: ' + bundle);
      }
    }

    if ((typeof bundle === 'undefined' ? 'undefined' : _typeof(bundle)) === 'object') {
      entry = bundle.entry;
      files = bundle.files;
      basedir = basedir || bundle.basedir;
      maps = (0, _sourceMapSupport.createSourceMapConsumers)(bundle.maps);
      if (typeof entry !== 'string' || (typeof files === 'undefined' ? 'undefined' : _typeof(files)) !== 'object') {
        throw new Error(INVALID_MSG);
      }
    } else if (typeof bundle === 'string') {
      entry = '__vue_ssr_bundle__';
      files = { '__vue_ssr_bundle__': bundle };
      maps = {};
    } else {
      throw new Error(INVALID_MSG);
    }

    var renderer = createRenderer(rendererOptions);

    var run = (0, _createBundleRunner.createBundleRunner)(entry, files, basedir, rendererOptions.runInNewContext);

    return {
      renderToString: function renderToString(context, cb) {
        if (typeof context === 'function') {
          cb = context;
          context = {};
        }

        var promise = void 0;
        if (!cb) {
          var _createPromiseCallbac = (0, _util.createPromiseCallback)();

          promise = _createPromiseCallbac.promise;
          cb = _createPromiseCallbac.cb;
        }

        run(context).catch(function (err) {
          (0, _sourceMapSupport.rewriteErrorTrace)(err, maps);
          cb(err);
        }).then(function (app) {
          if (app) {
            renderer.renderToString(app, context, function (err, res) {
              (0, _sourceMapSupport.rewriteErrorTrace)(err, maps);
              cb(err, res);
            });
          }
        });

        return promise;
      },

      renderToStream: function renderToStream(context) {
        var res = new PassThrough();
        run(context).catch(function (err) {
          (0, _sourceMapSupport.rewriteErrorTrace)(err, maps);
          // avoid emitting synchronously before user can
          // attach error listener
          process.nextTick(function () {
            res.emit('error', err);
          });
        }).then(function (app) {
          if (app) {
            var renderStream = renderer.renderToStream(app, context);

            renderStream.on('error', function (err) {
              (0, _sourceMapSupport.rewriteErrorTrace)(err, maps);
              res.emit('error', err);
            });

            // relay HTMLStream special events
            if (rendererOptions && rendererOptions.template) {
              renderStream.on('beforeStart', function () {
                res.emit('beforeStart');
              });
              renderStream.on('beforeEnd', function () {
                res.emit('beforeEnd');
              });
            }

            renderStream.pipe(res);
          }
        });

        return res;
      }
    };
  };
}

