'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EXPRESSION = exports.INTERPOLATION = exports.RAW = undefined;
exports.generate = generate;

var _index = require('compiler/codegen/index');

var _modules = require('./modules');

var _util = require('web/server/util');

var _optimizer = require('./optimizer');

// segment types


// The SSR codegen is essentially extending the default codegen to handle
// SSR-optimizable nodes and turn them into string render fns. In cases where
// a node is not optimizable it simply falls back to the default codegen.

var RAW = exports.RAW = 0;
var INTERPOLATION = exports.INTERPOLATION = 1;
var EXPRESSION = exports.EXPRESSION = 2;

function generate(ast, options) {
  var state = new _index.CodegenState(options);
  var code = ast ? genSSRElement(ast, state) : '_c("div")';
  return {
    render: 'with(this){return ' + code + '}',
    staticRenderFns: state.staticRenderFns
  };
}

function genSSRElement(el, state) {
  if (el.for && !el.forProcessed) {
    return (0, _index.genFor)(el, state, genSSRElement);
  } else if (el.if && !el.ifProcessed) {
    return (0, _index.genIf)(el, state, genSSRElement);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return el.ssrOptimizability === _optimizer.optimizability.FULL ? genChildrenAsStringNode(el, state) : genSSRChildren(el, state) || 'void 0';
  }

  switch (el.ssrOptimizability) {
    case _optimizer.optimizability.FULL:
      // stringify whole tree
      return genStringElement(el, state);
    case _optimizer.optimizability.SELF:
      // stringify self and check children
      return genStringElementWithChildren(el, state);
    case _optimizer.optimizability.CHILDREN:
      // generate self as VNode and stringify children
      return genNormalElement(el, state, true);
    case _optimizer.optimizability.PARTIAL:
      // generate self as VNode and check children
      return genNormalElement(el, state, false);
    default:
      // bail whole tree
      return (0, _index.genElement)(el, state);
  }
}

function genNormalElement(el, state, stringifyChildren) {
  var data = el.plain ? undefined : (0, _index.genData)(el, state);
  var children = stringifyChildren ? '[' + genChildrenAsStringNode(el, state) + ']' : genSSRChildren(el, state, true);
  return '_c(\'' + el.tag + '\'' + (data ? ',' + data : '') + (children ? ',' + children : '') + ')';
}

function genSSRChildren(el, state, checkSkip) {
  return (0, _index.genChildren)(el, state, checkSkip, genSSRElement, genSSRNode);
}

function genSSRNode(el, state) {
  return el.type === 1 ? genSSRElement(el, state) : (0, _index.genText)(el);
}

function genChildrenAsStringNode(el, state) {
  return el.children.length ? '_ssrNode(' + flattenSegments(childrenToSegments(el, state)) + ')' : '';
}

function genStringElement(el, state) {
  return '_ssrNode(' + elementToString(el, state) + ')';
}

function genStringElementWithChildren(el, state) {
  var children = genSSRChildren(el, state, true);
  return '_ssrNode(' + flattenSegments(elementToOpenTagSegments(el, state)) + ',"</' + el.tag + '>"' + (children ? ',' + children : '') + ')';
}

function elementToString(el, state) {
  return '(' + flattenSegments(elementToSegments(el, state)) + ')';
}

function elementToSegments(el, state) {
  // v-for / v-if
  if (el.for && !el.forProcessed) {
    el.forProcessed = true;
    return [{
      type: EXPRESSION,
      value: (0, _index.genFor)(el, state, elementToString, '_ssrList')
    }];
  } else if (el.if && !el.ifProcessed) {
    el.ifProcessed = true;
    return [{
      type: EXPRESSION,
      value: (0, _index.genIf)(el, state, elementToString, '"<!---->"')
    }];
  } else if (el.tag === 'template') {
    return childrenToSegments(el, state);
  }

  var openSegments = elementToOpenTagSegments(el, state);
  var childrenSegments = childrenToSegments(el, state);
  var isUnaryTag = state.options.isUnaryTag;

  var close = isUnaryTag && isUnaryTag(el.tag) ? [] : [{ type: RAW, value: '</' + el.tag + '>' }];
  return openSegments.concat(childrenSegments, close);
}

function elementToOpenTagSegments(el, state) {
  (0, _modules.applyModelTransform)(el, state);
  var binding = void 0;
  var segments = [{ type: RAW, value: '<' + el.tag }];
  // attrs
  if (el.attrs) {
    segments.push.apply(segments, (0, _modules.genAttrSegments)(el.attrs));
  }
  // domProps
  if (el.props) {
    segments.push.apply(segments, (0, _modules.genDOMPropSegments)(el.props, el.attrs));
  }
  // v-bind="object"
  if (binding = el.attrsMap['v-bind']) {
    segments.push({ type: EXPRESSION, value: '_ssrAttrs(' + binding + ')' });
  }
  // v-bind.prop="object"
  if (binding = el.attrsMap['v-bind.prop']) {
    segments.push({ type: EXPRESSION, value: '_ssrDOMProps(' + binding + ')' });
  }
  // class
  if (el.staticClass || el.classBinding) {
    segments.push.apply(segments, (0, _modules.genClassSegments)(el.staticClass, el.classBinding));
  }
  // style & v-show
  if (el.staticStyle || el.styleBinding || el.attrsMap['v-show']) {
    segments.push.apply(segments, (0, _modules.genStyleSegments)(el.attrsMap.style, el.staticStyle, el.styleBinding, el.attrsMap['v-show']));
  }
  // _scopedId
  if (state.options.scopeId) {
    segments.push({ type: RAW, value: ' ' + state.options.scopeId });
  }
  segments.push({ type: RAW, value: '>' });
  return segments;
}

function childrenToSegments(el, state) {
  var binding = void 0;
  if (binding = el.attrsMap['v-html']) {
    return [{ type: EXPRESSION, value: '_s(' + binding + ')' }];
  }
  if (binding = el.attrsMap['v-text']) {
    return [{ type: INTERPOLATION, value: '_s(' + binding + ')' }];
  }
  if (el.tag === 'textarea' && (binding = el.attrsMap['v-model'])) {
    return [{ type: INTERPOLATION, value: '_s(' + binding + ')' }];
  }
  return el.children ? nodesToSegments(el.children, state) : [];
}

function nodesToSegments(children, state) {
  var segments = [];
  for (var i = 0; i < children.length; i++) {
    var c = children[i];
    if (c.type === 1) {
      segments.push.apply(segments, elementToSegments(c, state));
    } else if (c.type === 2) {
      segments.push({ type: INTERPOLATION, value: c.expression });
    } else if (c.type === 3) {
      segments.push({ type: RAW, value: (0, _util.escape)(c.text) });
    }
  }
  return segments;
}

function flattenSegments(segments) {
  var mergedSegments = [];
  var textBuffer = '';

  var pushBuffer = function pushBuffer() {
    if (textBuffer) {
      mergedSegments.push(JSON.stringify(textBuffer));
      textBuffer = '';
    }
  };

  for (var i = 0; i < segments.length; i++) {
    var s = segments[i];
    if (s.type === RAW) {
      textBuffer += s.value;
    } else if (s.type === INTERPOLATION) {
      pushBuffer();
      mergedSegments.push('_ssrEscape(' + s.value + ')');
    } else if (s.type === EXPRESSION) {
      pushBuffer();
      mergedSegments.push('(' + s.value + ')');
    }
  }
  pushBuffer();

  return mergedSegments.join('+');
}

