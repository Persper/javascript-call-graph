'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optimizability = undefined;
exports.optimize = optimize;

var _util = require('shared/util');

// optimizability constants
var optimizability = exports.optimizability = {
  FALSE: 0, // whole sub tree un-optimizable
  FULL: 1, // whole sub tree optimizable
  SELF: 2, // self optimizable but has some un-optimizable children
  CHILDREN: 3, // self un-optimizable but have fully optimizable children
  PARTIAL: 4 // self un-optimizable with some un-optimizable children
};

/**
 * In SSR, the vdom tree is generated only once and never patched, so
 * we can optimize most element / trees into plain string render functions.
 * The SSR optimizer walks the AST tree to detect optimizable elements and trees.
 *
 * The criteria for SSR optimizability is quite a bit looser than static tree
 * detection (which is designed for client re-render). In SSR we bail only for
 * components/slots/custom directives.
 */

var isPlatformReservedTag = void 0;

function optimize(root, options) {
  if (!root) return;
  isPlatformReservedTag = options.isReservedTag || _util.no;
  walk(root, true);
}

function walk(node, isRoot) {
  if (isUnOptimizableTree(node)) {
    node.ssrOptimizability = optimizability.FALSE;
    return;
  }
  // root node or nodes with custom directives should always be a VNode
  var selfUnoptimizable = isRoot || hasCustomDirective(node);
  var check = function check(child) {
    if (child.ssrOptimizability !== optimizability.FULL) {
      node.ssrOptimizability = selfUnoptimizable ? optimizability.PARTIAL : optimizability.SELF;
    }
  };
  if (selfUnoptimizable) {
    node.ssrOptimizability = optimizability.CHILDREN;
  }
  if (node.type === 1) {
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      walk(child);
      check(child);
    }
    if (node.ifConditions) {
      for (var _i = 1, _l = node.ifConditions.length; _i < _l; _i++) {
        var block = node.ifConditions[_i].block;
        walk(block, isRoot);
        check(block);
      }
    }
    if (node.ssrOptimizability == null || !isRoot && (node.attrsMap['v-html'] || node.attrsMap['v-text'])) {
      node.ssrOptimizability = optimizability.FULL;
    } else {
      node.children = optimizeSiblings(node);
    }
  } else {
    node.ssrOptimizability = optimizability.FULL;
  }
}

function optimizeSiblings(el) {
  var children = el.children;
  var optimizedChildren = [];

  var currentOptimizableGroup = [];
  var pushGroup = function pushGroup() {
    if (currentOptimizableGroup.length) {
      optimizedChildren.push({
        type: 1,
        parent: el,
        tag: 'template',
        attrsList: [],
        attrsMap: {},
        children: currentOptimizableGroup,
        ssrOptimizability: optimizability.FULL
      });
    }
    currentOptimizableGroup = [];
  };

  for (var i = 0; i < children.length; i++) {
    var c = children[i];
    if (c.ssrOptimizability === optimizability.FULL) {
      currentOptimizableGroup.push(c);
    } else {
      // wrap fully-optimizable adjacent siblings inside a template tag
      // so that they can be optimized into a single ssrNode by codegen
      pushGroup();
      optimizedChildren.push(c);
    }
  }
  pushGroup();
  return optimizedChildren;
}

function isUnOptimizableTree(node) {
  if (node.type === 2 || node.type === 3) {
    // text or expression
    return false;
  }
  return (0, _util.isBuiltInTag)(node.tag) || // built-in (slot, component)
  !isPlatformReservedTag(node.tag) || // custom component
  !!node.component || // "is" component
  isSelectWithModel(node) // <select v-model> requires runtime inspection
  ;
}

var isBuiltInDir = (0, _util.makeMap)('text,html,show,on,bind,model,pre,cloak,once');

function hasCustomDirective(node) {
  return node.type === 1 && node.directives && node.directives.some(function (d) {
    return !isBuiltInDir(d.name);
  });
}

// <select v-model> cannot be optimized because it requires a runtime check
// to determine proper selected option
function isSelectWithModel(node) {
  return node.type === 1 && node.tag === 'select' && node.directives != null && node.directives.some(function (d) {
    return d.name === 'model';
  });
}

