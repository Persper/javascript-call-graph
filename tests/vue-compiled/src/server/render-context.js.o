'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderContext = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _util = require('shared/util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RenderContext = exports.RenderContext = function () {
  function RenderContext(options) {
    _classCallCheck(this, RenderContext);

    this.userContext = options.userContext;
    this.activeInstance = options.activeInstance;
    this.renderStates = [];

    this.write = options.write;
    this.done = options.done;
    this.renderNode = options.renderNode;

    this.isUnaryTag = options.isUnaryTag;
    this.modules = options.modules;
    this.directives = options.directives;

    var cache = options.cache;
    if (cache && (!cache.get || !cache.set)) {
      throw new Error('renderer cache must implement at least get & set.');
    }
    this.cache = cache;
    this.get = cache && normalizeAsync(cache, 'get');
    this.has = cache && normalizeAsync(cache, 'has');

    this.next = this.next.bind(this);
  }

  _createClass(RenderContext, [{
    key: 'next',
    value: function next() {
      var lastState = this.renderStates[this.renderStates.length - 1];
      if ((0, _util.isUndef)(lastState)) {
        return this.done();
      }
      switch (lastState.type) {
        case 'Element':
        case 'Fragment':
          var _children = lastState.children,
              _total = lastState.total;

          var _rendered = lastState.rendered++;
          if (_rendered < _total) {
            this.renderNode(_children[_rendered], false, this);
          } else {
            this.renderStates.pop();
            if (lastState.type === 'Element') {
              this.write(lastState.endTag, this.next);
            } else {
              this.next();
            }
          }
          break;
        case 'Component':
          this.renderStates.pop();
          this.activeInstance = lastState.prevActive;
          this.next();
          break;
        case 'ComponentWithCache':
          this.renderStates.pop();
          var _buffer = lastState.buffer,
              _bufferIndex = lastState.bufferIndex,
              _componentBuffer = lastState.componentBuffer,
              _key = lastState.key;

          var result = {
            html: _buffer[_bufferIndex],
            components: _componentBuffer[_bufferIndex]
          };
          this.cache.set(_key, result);
          if (_bufferIndex === 0) {
            // this is a top-level cached component,
            // exit caching mode.
            this.write.caching = false;
          } else {
            // parent component is also being cached,
            // merge self into parent's result
            _buffer[_bufferIndex - 1] += result.html;
            var prev = _componentBuffer[_bufferIndex - 1];
            result.components.forEach(function (c) {
              return prev.add(c);
            });
          }
          _buffer.length = _bufferIndex;
          _componentBuffer.length = _bufferIndex;
          this.next();
          break;
      }
    }
  }]);

  return RenderContext;
}();

function normalizeAsync(cache, method) {
  var fn = cache[method];
  if ((0, _util.isUndef)(fn)) {
    return;
  } else if (fn.length > 1) {
    return function (key, cb) {
      return fn.call(cache, key, cb);
    };
  } else {
    return function (key, cb) {
      return cb(fn.call(cache, key));
    };
  }
}

