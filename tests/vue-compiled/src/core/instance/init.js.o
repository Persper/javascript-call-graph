'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMixin = initMixin;
exports.initInternalComponent = initInternalComponent;
exports.resolveConstructorOptions = resolveConstructorOptions;

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

var _proxy = require('./proxy');

var _state = require('./state');

var _render = require('./render');

var _events = require('./events');

var _perf = require('../util/perf');

var _lifecycle = require('./lifecycle');

var _inject = require('./inject');

var _index = require('../util/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag = void 0,
        endTag = void 0;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && _config2.default.performance && _perf.mark) {
      startTag = 'vue-perf-start:' + vm._uid;
      endTag = 'vue-perf-end:' + vm._uid;
      (0, _perf.mark)(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = (0, _index.mergeOptions)(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      (0, _proxy.initProxy)(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    (0, _lifecycle.initLifecycle)(vm);
    (0, _events.initEvents)(vm);
    (0, _render.initRender)(vm);
    (0, _lifecycle.callHook)(vm, 'beforeCreate');
    (0, _inject.initInjections)(vm); // resolve injections before data/props
    (0, _state.initState)(vm);
    (0, _inject.initProvide)(vm); // resolve provide after data/props
    (0, _lifecycle.callHook)(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && _config2.default.performance && _perf.mark) {
      vm._name = (0, _index.formatComponentName)(vm, false);
      (0, _perf.mark)(endTag);
      (0, _perf.measure)('vue ' + vm._name + ' init', startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        (0, _index.extend)(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = (0, _index.mergeOptions)(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified = void 0;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) modified = {};
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

