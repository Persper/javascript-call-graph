'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAsyncPlaceholder = createAsyncPlaceholder;
exports.resolveAsyncComponent = resolveAsyncComponent;

var _index = require('core/util/index');

var _vnode = require('core/vdom/vnode');

function ensureCtor(comp, base) {
  if (comp.__esModule || _index.hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return (0, _index.isObject)(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = (0, _vnode.createEmptyVNode)();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if ((0, _index.isTrue)(factory.error) && (0, _index.isDef)(factory.errorComp)) {
    return factory.errorComp;
  }

  if ((0, _index.isDef)(factory.resolved)) {
    return factory.resolved;
  }

  if ((0, _index.isTrue)(factory.loading) && (0, _index.isDef)(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if ((0, _index.isDef)(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = (0, _index.once)(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = (0, _index.once)(function (reason) {
      process.env.NODE_ENV !== 'production' && (0, _index.warn)('Failed to resolve async component: ' + String(factory) + (reason ? '\nReason: ' + reason : ''));
      if ((0, _index.isDef)(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if ((0, _index.isObject)(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if ((0, _index.isUndef)(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if ((0, _index.isDef)(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if ((0, _index.isDef)(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if ((0, _index.isDef)(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if ((0, _index.isUndef)(factory.resolved) && (0, _index.isUndef)(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if ((0, _index.isDef)(res.timeout)) {
          setTimeout(function () {
            if ((0, _index.isUndef)(factory.resolved)) {
              reject(process.env.NODE_ENV !== 'production' ? 'timeout (' + res.timeout + 'ms)' : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

