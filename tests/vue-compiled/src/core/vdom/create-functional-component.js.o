'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionalRenderContext = FunctionalRenderContext;
exports.createFunctionalComponent = createFunctionalComponent;

var _vnode = require('./vnode');

var _vnode2 = _interopRequireDefault(_vnode);

var _createElement = require('./create-element');

var _inject = require('../instance/inject');

var _normalizeChildren = require('../vdom/helpers/normalize-children');

var _resolveSlots = require('../instance/render-helpers/resolve-slots');

var _index = require('../instance/render-helpers/index');

var _index2 = require('../util/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = void 0;
  if ((0, _index2.hasOwn)(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = (0, _index2.isTrue)(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || _index2.emptyObject;
  this.injections = (0, _inject.resolveInject)(options.inject, parent);
  this.slots = function () {
    return (0, _resolveSlots.resolveSlots)(children, parent);
  };

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || _index2.emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = (0, _createElement.createElement)(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return (0, _createElement.createElement)(contextVm, a, b, c, d, needNormalization);
    };
  }
}

(0, _index.installRenderHelpers)(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if ((0, _index2.isDef)(propOptions)) {
    for (var key in propOptions) {
      props[key] = (0, _index2.validateProp)(key, propOptions, propsData || _index2.emptyObject);
    }
  } else {
    if ((0, _index2.isDef)(data.attrs)) mergeProps(props, data.attrs);
    if ((0, _index2.isDef)(data.props)) mergeProps(props, data.props);
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof _vnode2.default) {
    setFunctionalContextForVNode(vnode, data, contextVm, options);
    return vnode;
  } else if (Array.isArray(vnode)) {
    var vnodes = (0, _normalizeChildren.normalizeChildren)(vnode) || [];
    for (var i = 0; i < vnodes.length; i++) {
      setFunctionalContextForVNode(vnodes[i], data, contextVm, options);
    }
    return vnodes;
  }
}

function setFunctionalContextForVNode(vnode, data, vm, options) {
  vnode.fnContext = vm;
  vnode.fnOptions = options;
  if (data.slot) {
    (vnode.data || (vnode.data = {})).slot = data.slot;
  }
}

function mergeProps(to, from) {
  for (var key in from) {
    to[(0, _index2.camelize)(key)] = from[key];
  }
}

