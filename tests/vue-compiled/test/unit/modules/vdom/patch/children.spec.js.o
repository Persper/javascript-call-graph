'use strict';

var _patch = require('web/runtime/patch');

var _vnode = require('core/vdom/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function prop(name) {
  return function (obj) {
    return obj[name];
  };
}

function map(fn, list) {
  var ret = [];
  for (var i = 0; i < list.length; i++) {
    ret[i] = fn(list[i]);
  }
  return ret;
}

function spanNum(n) {
  if (typeof n === 'string') {
    return new _vnode2.default('span', {}, undefined, n);
  } else {
    return new _vnode2.default('span', { key: n }, undefined, n.toString());
  }
}

function shuffle(array) {
  var currentIndex = array.length;
  var temporaryValue = void 0;
  var randomIndex = void 0;

  // while there remain elements to shuffle...
  while (currentIndex !== 0) {
    // pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    // and swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}

var inner = prop('innerHTML');
var tag = prop('tagName');

describe('vdom patch: children', function () {
  var vnode0 = void 0;
  beforeEach(function () {
    vnode0 = new _vnode2.default('p', { attrs: { id: '1' } }, [createTextVNode('hello world')]);
    (0, _patch.patch)(null, vnode0);
  });

  it('should appends elements', function () {
    var vnode1 = new _vnode2.default('p', {}, [1].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 3].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(1);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(3);
    expect(elm.children[1].innerHTML).toBe('2');
    expect(elm.children[2].innerHTML).toBe('3');
  });

  it('should prepends elements', function () {
    var vnode1 = new _vnode2.default('p', {}, [4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(2);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3', '4', '5']);
  });

  it('should add elements in the middle', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(4);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3', '4', '5']);
  });

  it('should add elements at begin and end', function () {
    var vnode1 = new _vnode2.default('p', {}, [2, 3, 4].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(3);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3', '4', '5']);
  });

  it('should add children to parent with no children', function () {
    var vnode1 = new _vnode2.default('p', { key: 'p' });
    var vnode2 = new _vnode2.default('p', { key: 'p' }, [1, 2, 3].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(0);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3']);
  });

  it('should remove all children from parent', function () {
    var vnode1 = new _vnode2.default('p', { key: 'p' }, [1, 2, 3].map(spanNum));
    var vnode2 = new _vnode2.default('p', { key: 'p' });
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(0);
  });

  it('should remove elements from the beginning', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [3, 4, 5].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(5);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['3', '4', '5']);
  });

  it('should removes elements from end', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 3].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(5);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(3);
    expect(map(inner, elm.children)).toEqual(['1', '2', '3']);
  });

  it('should remove elements from the middle', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 2, 4, 5].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(5);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(4);
    expect(map(inner, elm.children)).toEqual(['1', '2', '4', '5']);
  });

  it('should moves element forward', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [2, 3, 1, 4].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(4);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(4);
    expect(map(inner, elm.children)).toEqual(['2', '3', '1', '4']);
  });

  it('should move elements to end', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [2, 3, 1].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(3);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(3);
    expect(map(inner, elm.children)).toEqual(['2', '3', '1']);
  });

  it('should move element backwards', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [1, 4, 2, 3].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(4);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(4);
    expect(map(inner, elm.children)).toEqual(['1', '4', '2', '3']);
  });

  it('should swap first and last', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [4, 2, 3, 1].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(4);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(4);
    expect(map(inner, elm.children)).toEqual(['4', '2', '3', '1']);
  });

  it('should move to left and replace', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [4, 1, 2, 3, 6].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(5);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(5);
    expect(map(inner, elm.children)).toEqual(['4', '1', '2', '3', '6']);
  });

  it('should move to left and leaves hold', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [4, 6].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(3);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['4', '6']);
  });

  it('should handle moved and set to undefined element ending at the end', function () {
    var vnode1 = new _vnode2.default('p', {}, [2, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [4, 5, 3].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(3);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(3);
    expect(map(inner, elm.children)).toEqual(['4', '5', '3']);
  });

  it('should move a key in non-keyed nodes with a size up', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 'a', 'b', 'c'].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, ['d', 'a', 'b', 'c', 1, 'e'].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(4);
    expect(elm.textContent, '1abc');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.children.length).toBe(6);
    expect(elm.textContent, 'dabc1e');
  });

  it('should reverse element', function () {
    var vnode1 = new _vnode2.default('p', {}, [1, 2, 3, 4, 5, 6, 7, 8].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [8, 7, 6, 5, 4, 3, 2, 1].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(8);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['8', '7', '6', '5', '4', '3', '2', '1']);
  });

  it('something', function () {
    var vnode1 = new _vnode2.default('p', {}, [0, 1, 2, 3, 4, 5].map(spanNum));
    var vnode2 = new _vnode2.default('p', {}, [4, 3, 2, 1, 5, 0].map(spanNum));
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.children.length).toBe(6);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['4', '3', '2', '1', '5', '0']);
  });

  it('should handle random shuffle', function () {
    var n = void 0;
    var i = void 0;
    var arr = [];
    var opacities = [];
    var elms = 14;
    var samples = 5;
    function spanNumWithOpacity(n, o) {
      return new _vnode2.default('span', { key: n, style: { opacity: o } }, undefined, n.toString());
    }

    for (n = 0; n < elms; ++n) {
      arr[n] = n;
    }

    var _loop = function _loop() {
      var vnode1 = new _vnode2.default('span', {}, arr.map(function (n) {
        return spanNumWithOpacity(n, '1');
      }));
      var shufArr = shuffle(arr.slice(0));
      var elm = (0, _patch.patch)(vnode0, vnode1);
      for (i = 0; i < elms; ++i) {
        expect(elm.children[i].innerHTML).toBe(i.toString());
        opacities[i] = Math.random().toFixed(5).toString();
      }
      var vnode2 = new _vnode2.default('span', {}, arr.map(function (n) {
        return spanNumWithOpacity(shufArr[n], opacities[n]);
      }));
      elm = (0, _patch.patch)(vnode1, vnode2);
      for (i = 0; i < elms; ++i) {
        expect(elm.children[i].innerHTML).toBe(shufArr[i].toString());
        expect(opacities[i].indexOf(elm.children[i].style.opacity)).toBe(0);
      }
    };

    for (n = 0; n < samples; ++n) {
      _loop();
    }
  });

  it('should append elements with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'hello')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'hello'), new _vnode2.default('span', {}, undefined, 'world')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['hello']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['hello', 'world']);
  });

  it('should handle unmoved text nodes with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [createTextVNode('text'), new _vnode2.default('span', {}, undefined, 'hello')]);
    var vnode2 = new _vnode2.default('div', {}, [createTextVNode('text'), new _vnode2.default('span', {}, undefined, 'hello')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.childNodes[0].textContent).toBe('text');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.childNodes[0].textContent).toBe('text');
  });

  it('should handle changing text children with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [createTextVNode('text'), new _vnode2.default('span', {}, undefined, 'hello')]);
    var vnode2 = new _vnode2.default('div', {}, [createTextVNode('text2'), new _vnode2.default('span', {}, undefined, 'hello')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.childNodes[0].textContent).toBe('text');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.childNodes[0].textContent).toBe('text2');
  });

  it('should prepend element with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'world')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'hello'), new _vnode2.default('span', {}, undefined, 'world')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['world']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['hello', 'world']);
  });

  it('should prepend element of different tag type with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'world')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('div', {}, undefined, 'hello'), new _vnode2.default('span', {}, undefined, 'world')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['world']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(prop('tagName'), elm.children)).toEqual(['DIV', 'SPAN']);
    expect(map(inner, elm.children)).toEqual(['hello', 'world']);
  });

  it('should remove elements with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'one'), new _vnode2.default('span', {}, undefined, 'two'), new _vnode2.default('span', {}, undefined, 'three')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'one'), new _vnode2.default('span', {}, undefined, 'three')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['one', 'two', 'three']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['one', 'three']);
  });

  it('should remove a single text node with updating children without keys', function () {
    var vnode1 = new _vnode2.default('div', {}, undefined, 'one');
    var vnode2 = new _vnode2.default('div', {});
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.textContent).toBe('one');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.textContent).toBe('');
  });

  it('should remove a single text node when children are updated', function () {
    var vnode1 = new _vnode2.default('div', {}, undefined, 'one');
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('div', {}, undefined, 'two'), new _vnode2.default('span', {}, undefined, 'three')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.textContent).toBe('one');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(prop('textContent'), elm.childNodes)).toEqual(['two', 'three']);
  });

  it('should remove a text node among other elements', function () {
    var vnode1 = new _vnode2.default('div', {}, [createTextVNode('one'), new _vnode2.default('span', {}, undefined, 'two')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('div', {}, undefined, 'three')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(prop('textContent'), elm.childNodes)).toEqual(['one', 'two']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.childNodes.length).toBe(1);
    expect(elm.childNodes[0].tagName).toBe('DIV');
    expect(elm.childNodes[0].textContent).toBe('three');
  });

  it('should reorder elements', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'one'), new _vnode2.default('div', {}, undefined, 'two'), new _vnode2.default('b', {}, undefined, 'three')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('b', {}, undefined, 'three'), new _vnode2.default('span', {}, undefined, 'two'), new _vnode2.default('div', {}, undefined, 'one')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(inner, elm.children)).toEqual(['one', 'two', 'three']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(inner, elm.children)).toEqual(['three', 'two', 'one']);
  });

  it('should handle children with the same key but with different tag', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('div', { key: 1 }, undefined, 'one'), new _vnode2.default('div', { key: 2 }, undefined, 'two'), new _vnode2.default('div', { key: 3 }, undefined, 'three'), new _vnode2.default('div', { key: 4 }, undefined, 'four')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('div', { key: 4 }, undefined, 'four'), new _vnode2.default('span', { key: 3 }, undefined, 'three'), new _vnode2.default('span', { key: 2 }, undefined, 'two'), new _vnode2.default('div', { key: 1 }, undefined, 'one')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(map(tag, elm.children)).toEqual(['DIV', 'DIV', 'DIV', 'DIV']);
    expect(map(inner, elm.children)).toEqual(['one', 'two', 'three', 'four']);
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(map(tag, elm.children)).toEqual(['DIV', 'SPAN', 'SPAN', 'DIV']);
    expect(map(inner, elm.children)).toEqual(['four', 'three', 'two', 'one']);
  });

  it('should handle children with the same tag, same key, but one with data and one without data', function () {
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('div', { class: 'hi' }, undefined, 'one')]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('div', undefined, undefined, 'four')]);
    var elm = (0, _patch.patch)(vnode0, vnode1);
    var child1 = elm.children[0];
    expect(child1.className).toBe('hi');
    elm = (0, _patch.patch)(vnode1, vnode2);
    var child2 = elm.children[0];
    expect(child1).not.toBe(child2);
    expect(child2.className).toBe('');
  });

  it('should handle static vnodes properly', function () {
    function makeNode(text) {
      return new _vnode2.default('div', undefined, [new _vnode2.default(undefined, undefined, undefined, text)]);
    }
    var b = makeNode('B');
    b.isStatic = true;
    b.key = '__static__1';
    var vnode1 = new _vnode2.default('div', {}, [makeNode('A'), b, makeNode('C')]);
    var vnode2 = new _vnode2.default('div', {}, [b]);
    var vnode3 = new _vnode2.default('div', {}, [makeNode('A'), b, makeNode('C')]);

    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.textContent).toBe('ABC');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.textContent).toBe('B');
    elm = (0, _patch.patch)(vnode2, vnode3);
    expect(elm.textContent).toBe('ABC');
  });

  it('should handle static vnodes inside ', function () {
    function makeNode(text) {
      return new _vnode2.default('div', undefined, [new _vnode2.default(undefined, undefined, undefined, text)]);
    }
    var b = makeNode('B');
    b.isStatic = true;
    b.key = '__static__1';
    var vnode1 = new _vnode2.default('div', {}, [makeNode('A'), b, makeNode('C')]);
    var vnode2 = new _vnode2.default('div', {}, [b]);
    var vnode3 = new _vnode2.default('div', {}, [makeNode('A'), b, makeNode('C')]);

    var elm = (0, _patch.patch)(vnode0, vnode1);
    expect(elm.textContent).toBe('ABC');
    elm = (0, _patch.patch)(vnode1, vnode2);
    expect(elm.textContent).toBe('B');
    elm = (0, _patch.patch)(vnode2, vnode3);
    expect(elm.textContent).toBe('ABC');
  });

  // #6502
  it('should not de-opt when both head and tail are changed', function () {
    var vnode1 = new _vnode2.default('div', {}, [(0, _vnode.createEmptyVNode)(), new _vnode2.default('div'), (0, _vnode.createEmptyVNode)()]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('p'), new _vnode2.default('div'), new _vnode2.default('p')]);
    var root = (0, _patch.patch)(null, vnode1);
    var original = root.childNodes[1];

    root = (0, _patch.patch)(vnode1, vnode2);
    var postPatch = root.childNodes[1];

    expect(postPatch).toBe(original);
  });

  it('should warn with duplicate keys: createChildren', function () {
    function makeNode(key) {
      return new _vnode2.default('div', { key: key });
    }

    var vnode = new _vnode2.default('p', {}, ['b', 'a', 'c', 'b'].map(makeNode));
    (0, _patch.patch)(null, vnode);
    expect('Duplicate keys detected: \'b\'').toHaveBeenWarned();
  });

  it('should warn with duplicate keys: updateChildren', function () {
    function makeNode(key) {
      return new _vnode2.default('div', { key: key });
    }

    var vnode2 = new _vnode2.default('p', {}, ['b', 'a', 'c', 'b'].map(makeNode));
    var vnode3 = new _vnode2.default('p', {}, ['b', 'x', 'd', 'b'].map(makeNode));
    (0, _patch.patch)(vnode0, vnode2);
    expect('Duplicate keys detected: \'b\'').toHaveBeenWarned();
    (0, _patch.patch)(vnode2, vnode3);
    expect('Duplicate keys detected: \'b\'').toHaveBeenWarned();
  });
});

