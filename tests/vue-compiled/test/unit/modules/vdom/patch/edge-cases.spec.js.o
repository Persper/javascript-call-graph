'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('vdom patch: edge cases', function () {
  // exposed by #3406
  // When a static vnode is inside v-for, it's possible for the same vnode
  // to be used in multiple places, and its element will be replaced. This
  // causes patch errors when node ops depend on the vnode's element position.
  it('should handle static vnodes by key', function (done) {
    var vm = new _vue2.default({
      data: {
        ok: true
      },
      template: '\n        <div>\n          <div v-for="i in 2">\n            <div v-if="ok">a</div><div>b</div><div v-if="!ok">c</div><div>d</div>\n          </div>\n        </div>\n      '
    }).$mount();
    expect(vm.$el.textContent).toBe('abdabd');
    vm.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('bcdbcd');
    }).then(done);
  });

  // exposed by #7705
  // methods and function expressions with modifiers should return result instead of undefined
  // skipped odd children[1,3, ...] because they are rendered as text nodes with undefined value
  it('should return listener\'s result for method name and function expression with and w/o modifiers', function (done) {
    var dummyEvt = { preventDefault: function preventDefault() {} };
    new _vue2.default({
      template: '\n        <div v-test>\n          <div @click="addFive"></div>\n          <div @click.prevent="addFive"></div>\n          <div @click="addFive($event, 5)"></div>\n          <div @click.prevent="addFive($event, 5)"></div>\n        </div>\n      ',
      methods: {
        addFive: function addFive($event) {
          var toAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          return toAdd + 5;
        }
      },
      directives: {
        test: {
          bind: function bind(el, binding, vnode) {
            waitForUpdate(function () {
              expect(vnode.children[0].data.on.click()).toBe(5);
            }).then(function () {
              expect(vnode.children[2].data.on.click(dummyEvt)).toBe(5);
            }).then(function () {
              expect(vnode.children[4].data.on.click()).not.toBeDefined();
            }).then(function () {
              expect(vnode.children[6].data.on.click(dummyEvt)).not.toBeDefined();
            }).then(done);
          }
        }
      }
    }).$mount();
  });

  // #3533
  // a static node is reused in createElm, which changes its elm reference
  // and is inserted into a different parent.
  // later when patching the next element a DOM insertion uses it as the
  // reference node, causing a parent mismatch.
  it('should handle static node edge case when it\'s reused AND used as a reference node for insertion', function (done) {
    var vm = new _vue2.default({
      data: {
        ok: true
      },
      template: '\n        <div>\n          <button @click="ok = !ok">toggle</button>\n          <div class="b" v-if="ok">123</div>\n          <div class="c">\n            <div><span/></div><p>{{ 1 }}</p>\n          </div>\n          <div class="d">\n            <label>{{ 2 }}</label>\n          </div>\n          <div class="b" v-if="ok">123</div>\n        </div>\n      '
    }).$mount();

    expect(vm.$el.querySelector('.c').textContent).toBe('1');
    expect(vm.$el.querySelector('.d').textContent).toBe('2');
    vm.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.querySelector('.c').textContent).toBe('1');
      expect(vm.$el.querySelector('.d').textContent).toBe('2');
    }).then(done);
  });

  it('should handle slot nodes being reused across render', function (done) {
    var vm = new _vue2.default({
      template: '\n        <foo ref="foo">\n          <div>slot</div>\n        </foo>\n      ',
      components: {
        foo: {
          data: function data() {
            return { ok: true };
          },
          render: function render(h) {
            var children = [this.ok ? h('div', 'toggler ') : null, h('div', [this.$slots.default, h('span', ' 1')]), h('div', [h('label', ' 2')])];
            return h('div', children);
          }
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toContain('toggler slot 1 2');
    vm.$refs.foo.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toContain('slot 1 2');
      vm.$refs.foo.ok = true;
    }).then(function () {
      expect(vm.$el.textContent).toContain('toggler slot 1 2');
      vm.$refs.foo.ok = false;
    }).then(function () {
      expect(vm.$el.textContent).toContain('slot 1 2');
      vm.$refs.foo.ok = true;
    }).then(done);
  });

  it('should synchronize vm\' vnode', function (done) {
    var comp = {
      data: function data() {
        return { swap: true };
      },
      render: function render(h) {
        return this.swap ? h('a', 'atag') : h('span', 'span');
      }
    };

    var wrapper = {
      render: function render(h) {
        return h('comp');
      },
      components: { comp: comp }
    };

    var vm = new _vue2.default({
      render: function render(h) {
        var children = [h('wrapper'), h('div', 'row')];
        if (this.swap) {
          children.reverse();
        }
        return h('div', children);
      },

      data: function data() {
        return { swap: false };
      },
      components: { wrapper: wrapper }
    }).$mount();

    expect(vm.$el.innerHTML).toBe('<a>atag</a><div>row</div>');
    var wrapperVm = vm.$children[0];
    var compVm = wrapperVm.$children[0];
    vm.swap = true;
    waitForUpdate(function () {
      expect(compVm.$vnode.parent).toBe(wrapperVm.$vnode);
      expect(vm.$el.innerHTML).toBe('<div>row</div><a>atag</a>');
      vm.swap = false;
    }).then(function () {
      expect(compVm.$vnode.parent).toBe(wrapperVm.$vnode);
      expect(vm.$el.innerHTML).toBe('<a>atag</a><div>row</div>');
      compVm.swap = false;
    }).then(function () {
      expect(vm.$el.innerHTML).toBe('<span>span</span><div>row</div>');
      expect(compVm.$vnode.parent).toBe(wrapperVm.$vnode);
      vm.swap = true;
    }).then(function () {
      expect(vm.$el.innerHTML).toBe('<div>row</div><span>span</span>');
      expect(compVm.$vnode.parent).toBe(wrapperVm.$vnode);
      vm.swap = true;
    }).then(done);
  });

  // #4530
  it('should not reset value when patching between dynamic/static bindings', function (done) {
    var vm = new _vue2.default({
      data: { ok: true },
      template: '\n        <div>\n          <input type="button" v-if="ok" value="a">\n          <input type="button" :value="\'b\'">\n        </div>\n      '
    }).$mount();
    expect(vm.$el.children[0].value).toBe('a');
    vm.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.children[0].value).toBe('b');
      vm.ok = true;
    }).then(function () {
      expect(vm.$el.children[0].value).toBe('a');
    }).then(done);
  });

  // #6313
  it('should not replace node when switching between text-like inputs', function (done) {
    var vm = new _vue2.default({
      data: { show: false },
      template: '\n        <div>\n          <input :type="show ? \'text\' : \'password\'">\n        </div>\n      '
    }).$mount();
    var node = vm.$el.children[0];
    expect(vm.$el.children[0].type).toBe('password');
    vm.$el.children[0].value = 'test';
    vm.show = true;
    waitForUpdate(function () {
      expect(vm.$el.children[0]).toBe(node);
      expect(vm.$el.children[0].value).toBe('test');
      expect(vm.$el.children[0].type).toBe('text');
      vm.show = false;
    }).then(function () {
      expect(vm.$el.children[0]).toBe(node);
      expect(vm.$el.children[0].value).toBe('test');
      expect(vm.$el.children[0].type).toBe('password');
    }).then(done);
  });

  it('should properly patch nested HOC when root element is replaced', function (done) {
    var vm = new _vue2.default({
      template: '<foo class="hello" ref="foo" />',
      components: {
        foo: {
          template: '<bar ref="bar" />',
          components: {
            bar: {
              template: '<div v-if="ok"></div><span v-else></span>',
              data: function data() {
                return { ok: true };
              }
            }
          }
        }
      }
    }).$mount();

    expect(vm.$refs.foo.$refs.bar.$el.tagName).toBe('DIV');
    expect(vm.$refs.foo.$refs.bar.$el.className).toBe('hello');

    vm.$refs.foo.$refs.bar.ok = false;
    waitForUpdate(function () {
      expect(vm.$refs.foo.$refs.bar.$el.tagName).toBe('SPAN');
      expect(vm.$refs.foo.$refs.bar.$el.className).toBe('hello');
    }).then(done);
  });

  // #6790
  it('should not render undefined for empty nested arrays', function () {
    var vm = new _vue2.default({
      template: '<div><template v-for="i in emptyArr"></template></div>',
      data: { emptyArr: [] }
    }).$mount();
    expect(vm.$el.textContent).toBe('');
  });

  // #6803
  it('backwards compat with checkbox code generated before 2.4', function () {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      data: {
        label: 'foobar',
        name: 'foobar'
      },
      computed: {
        value: {
          get: function get() {
            return 1;
          },

          set: spy
        }
      },
      render: function render(h) {
        var _vm = this;
        return h('div', {}, [h('input', {
          directives: [{
            name: 'model',
            rawName: 'v-model',
            value: _vm.value,
            expression: 'value'
          }],
          attrs: {
            'type': 'radio',
            'name': _vm.name
          },
          domProps: {
            'value': _vm.label,
            'checked': _vm._q(_vm.value, _vm.label)
          },
          on: {
            '__c': function __c($event) {
              _vm.value = _vm.label;
            }
          }
        })]);
      }
    }).$mount();

    document.body.appendChild(vm.$el);
    vm.$el.children[0].click();
    expect(spy).toHaveBeenCalled();
  });

  // #7041
  it('transition children with only deep bindings should be patched on update', function (done) {
    var vm = new _vue2.default({
      template: '\n      <div>\n        <transition>\n          <div :style="style"></div>\n        </transition>\n      </div>\n      ',
      data: function data() {
        return {
          style: { color: 'red' }
        };
      }
    }).$mount();
    expect(vm.$el.children[0].style.color).toBe('red');
    vm.style.color = 'green';
    waitForUpdate(function () {
      expect(vm.$el.children[0].style.color).toBe('green');
    }).then(done);
  });

  // #7294
  it('should cleanup component inline events on patch when no events are present', function (done) {
    var log = jasmine.createSpy();
    var vm = new _vue2.default({
      data: { ok: true },
      template: '\n        <div>\n          <foo v-if="ok" @custom="log"/>\n          <foo v-else/>\n        </div>\n      ',
      components: {
        foo: {
          render: function render() {}
        }
      },
      methods: { log: log }
    }).$mount();

    vm.ok = false;
    waitForUpdate(function () {
      vm.$children[0].$emit('custom');
      expect(log).not.toHaveBeenCalled();
    }).then(done);
  });

  // #6864
  it('should not special-case boolean attributes for custom elements', function () {
    _vue2.default.config.ignoredElements = [/^custom-/];
    var vm = new _vue2.default({
      template: '<div><custom-foo selected="1"/></div>'
    }).$mount();
    expect(vm.$el.querySelector('custom-foo').getAttribute('selected')).toBe('1');
    _vue2.default.config.ignoredElements = [];
  });

  // #7805
  it('should not cause duplicate init when components share data object', function () {
    var Base = {
      render: function render(h) {
        return h('div', this.$options.name);
      }
    };

    var Foo = {
      name: 'Foo',
      extends: Base
    };

    var Bar = {
      name: 'Bar',
      extends: Base
    };

    var vm = new _vue2.default({
      render: function render(h) {
        var data = { staticClass: 'text-red' };

        return h('div', [h(Foo, data), h(Bar, data)]);
      }
    }).$mount();

    expect(vm.$el.textContent).toBe('FooBar');
  });
});

