'use strict';

var _patch = require('web/runtime/patch');

var _patch2 = require('core/vdom/patch');

var _index = require('core/vdom/modules/index');

var _index2 = _interopRequireDefault(_index);

var _nodeOps = require('web/runtime/node-ops');

var nodeOps = _interopRequireWildcard(_nodeOps);

var _index3 = require('web/runtime/modules/index');

var _index4 = _interopRequireDefault(_index3);

var _vnode = require('core/vdom/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modules = _index2.default.concat(_index4.default);

describe('vdom patch: hooks', function () {
  var vnode0 = void 0;
  beforeEach(function () {
    vnode0 = new _vnode2.default('p', { attrs: { id: '1' } }, [createTextVNode('hello world')]);
    (0, _patch.patch)(null, vnode0);
  });

  it('should call `insert` listener after both parents, siblings and children have been inserted', function () {
    var result = [];
    function insert(vnode) {
      expect(vnode.elm.children.length).toBe(2);
      expect(vnode.elm.parentNode.children.length).toBe(3);
      result.push(vnode);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { insert: insert } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')]), new _vnode2.default('span', {}, undefined, 'can touch me')]);
    (0, _patch.patch)(vnode0, vnode1);
    expect(result.length).toBe(1);
  });

  it('should call `prepatch` listener', function () {
    var result = [];
    function prepatch(oldVnode, newVnode) {
      expect(oldVnode).toEqual(vnode1.children[1]);
      expect(newVnode).toEqual(vnode2.children[1]);
      result.push(newVnode);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { prepatch: prepatch } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { prepatch: prepatch } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(result.length).toBe(1);
  });

  it('should call `postpatch` after `prepatch` listener', function () {
    var pre = [];
    var post = [];
    function prepatch(oldVnode, newVnode) {
      pre.push(pre);
    }
    function postpatch(oldVnode, newVnode) {
      expect(pre.length).toBe(post.length + 1);
      post.push(post);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { prepatch: prepatch, postpatch: postpatch } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { prepatch: prepatch, postpatch: postpatch } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(pre.length).toBe(1);
    expect(post.length).toBe(1);
  });

  it('should call `update` listener', function () {
    var result1 = [];
    var result2 = [];
    function cb(result, oldVnode, newVnode) {
      if (result.length > 1) {
        expect(result[result.length - 1]).toEqual(oldVnode);
      }
      result.push(newVnode);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { update: cb.bind(null, result1) } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', { hook: { update: cb.bind(null, result2) } }, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { update: cb.bind(null, result1) } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', { hook: { update: cb.bind(null, result2) } }, undefined, 'child 2')])]);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(result1.length).toBe(1);
    expect(result2.length).toBe(1);
  });

  it('should call `remove` listener', function () {
    var result = [];
    function remove(vnode, rm) {
      var parent = vnode.elm.parentNode;
      expect(vnode.elm.children.length).toBe(2);
      expect(vnode.elm.children.length).toBe(2);
      result.push(vnode);
      rm();
      expect(parent.children.length).toBe(1);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { remove: remove } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling')]);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(result.length).toBe(1);
  });

  it('should call `init` and `prepatch` listeners on root', function () {
    var count = 0;
    function init(vnode) {
      count++;
    }
    function prepatch(oldVnode, newVnode) {
      count++;
    }
    var vnode1 = new _vnode2.default('div', { hook: { init: init, prepatch: prepatch } });
    (0, _patch.patch)(vnode0, vnode1);
    expect(count).toBe(1);
    var vnode2 = new _vnode2.default('span', { hook: { init: init, prepatch: prepatch } });
    (0, _patch.patch)(vnode1, vnode2);
    expect(count).toBe(2);
  });

  it('should remove element when all remove listeners are done', function () {
    var rm1 = void 0,
        rm2 = void 0,
        rm3 = void 0;
    var patch1 = (0, _patch2.createPatchFunction)({
      nodeOps: nodeOps,
      modules: modules.concat([{
        remove: function remove(_, rm) {
          rm1 = rm;
        }
      }, {
        remove: function remove(_, rm) {
          rm2 = rm;
        }
      }])
    });
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('a', { hook: {
        remove: function remove(_, rm) {
          rm3 = rm;
        }
      } })]);
    var vnode2 = new _vnode2.default('div', {}, []);
    var elm = patch1(vnode0, vnode1);
    expect(elm.children.length).toBe(1);
    elm = patch1(vnode1, vnode2);
    expect(elm.children.length).toBe(1);
    rm1();
    expect(elm.children.length).toBe(1);
    rm3();
    expect(elm.children.length).toBe(1);
    rm2();
    expect(elm.children.length).toBe(0);
  });

  it('should invoke the remove hook on replaced root', function () {
    var result = [];
    var parent = nodeOps.createElement('div');
    vnode0 = nodeOps.createElement('div');
    parent.appendChild(vnode0);
    function remove(vnode, rm) {
      result.push(vnode);
      rm();
    }
    var vnode1 = new _vnode2.default('div', { hook: { remove: remove } }, [new _vnode2.default('b', {}, undefined, 'child 1'), new _vnode2.default('i', {}, undefined, 'child 2')]);
    var vnode2 = new _vnode2.default('span', {}, [new _vnode2.default('b', {}, undefined, 'child 1'), new _vnode2.default('i', {}, undefined, 'child 2')]);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(result.length).toBe(1);
  });

  it('should invoke global `destroy` hook for all removed children', function () {
    var result = [];
    function destroy(vnode) {
      result.push(vnode);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', {}, [new _vnode2.default('span', { hook: { destroy: destroy } }, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div');
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
    expect(result.length).toBe(1);
  });

  it('should handle text vnodes with `undefined` `data` property', function () {
    var vnode1 = new _vnode2.default('div', {}, [createTextVNode(' ')]);
    var vnode2 = new _vnode2.default('div', {}, []);
    (0, _patch.patch)(vnode0, vnode1);
    (0, _patch.patch)(vnode1, vnode2);
  });

  it('should invoke `destroy` module hook for all removed children', function () {
    var created = 0;
    var destroyed = 0;
    var patch1 = (0, _patch2.createPatchFunction)({
      nodeOps: nodeOps,
      modules: modules.concat([{
        create: function create() {
          created++;
        }
      }, {
        destroy: function destroy() {
          destroyed++;
        }
      }])
    });
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')])]);
    var vnode2 = new _vnode2.default('div', {});
    patch1(vnode0, vnode1);
    expect(destroyed).toBe(1); // should invoke for replaced root nodes too
    patch1(vnode1, vnode2);
    expect(created).toBe(5);
    expect(destroyed).toBe(5);
  });

  it('should not invoke `create` and `remove` module hook for text nodes', function () {
    var created = 0;
    var removed = 0;
    var patch1 = (0, _patch2.createPatchFunction)({
      nodeOps: nodeOps,
      modules: modules.concat([{
        create: function create() {
          created++;
        }
      }, {
        remove: function remove() {
          removed++;
        }
      }])
    });
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first child'), createTextVNode(''), new _vnode2.default('span', {}, undefined, 'third child')]);
    var vnode2 = new _vnode2.default('div', {});
    patch1(vnode0, vnode1);
    patch1(vnode1, vnode2);
    expect(created).toBe(3);
    expect(removed).toBe(2);
  });

  it('should not invoke `destroy` module hook for text nodes', function () {
    var created = 0;
    var destroyed = 0;
    var patch1 = (0, _patch2.createPatchFunction)({
      nodeOps: nodeOps,
      modules: modules.concat([{
        create: function create() {
          created++;
        }
      }, {
        destroy: function destroy() {
          destroyed++;
        }
      }])
    });
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, [createTextVNode('text1'), createTextVNode('text2')])])]);
    var vnode2 = new _vnode2.default('div', {});
    patch1(vnode0, vnode1);
    expect(destroyed).toBe(1); // should invoke for replaced root nodes too
    patch1(vnode1, vnode2);
    expect(created).toBe(5);
    expect(destroyed).toBe(5);
  });

  it('should call `create` listener before inserted into parent but after children', function () {
    var result = [];
    function create(empty, vnode) {
      expect(vnode.elm.children.length).toBe(2);
      expect(vnode.elm.parentNode).toBe(null);
      result.push(vnode);
    }
    var vnode1 = new _vnode2.default('div', {}, [new _vnode2.default('span', {}, undefined, 'first sibling'), new _vnode2.default('div', { hook: { create: create } }, [new _vnode2.default('span', {}, undefined, 'child 1'), new _vnode2.default('span', {}, undefined, 'child 2')]), new _vnode2.default('span', {}, undefined, 'can\'t touch me')]);
    (0, _patch.patch)(vnode0, vnode1);
    expect(result.length).toBe(1);
  });
});

