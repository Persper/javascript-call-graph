'use strict';

var _parser = require('sfc/parser');

describe('Single File Component parser', function () {
  it('should parse', function () {
    var res = (0, _parser.parseComponent)('\n      <template>\n        <div>hi</div>\n      </template>\n      <style src="./test.css"></style>\n      <style lang="stylus" scoped>\n        h1\n          color red\n        h2\n          color green\n      </style>\n      <style module>\n        h1 { font-weight: bold }\n      </style>\n      <style bool-attr val-attr="test"></style>\n      <script>\n        export default {}\n      </script>\n      <div>\n        <style>nested should be ignored</style>\n      </div>\n    ');
    expect(res.template.content.trim()).toBe('<div>hi</div>');
    expect(res.styles.length).toBe(4);
    expect(res.styles[0].src).toBe('./test.css');
    expect(res.styles[1].lang).toBe('stylus');
    expect(res.styles[1].scoped).toBe(true);
    expect(res.styles[1].content.trim()).toBe('h1\n  color red\nh2\n  color green');
    expect(res.styles[2].module).toBe(true);
    expect(res.styles[3].attrs['bool-attr']).toBe(true);
    expect(res.styles[3].attrs['val-attr']).toBe('test');
    expect(res.script.content.trim()).toBe('export default {}');
  });

  it('should parse template with closed input', function () {
    var res = (0, _parser.parseComponent)('\n      <template>\n        <input type="text"/>\n      </template>\n    ');

    expect(res.template.content.trim()).toBe('<input type="text"/>');
  });

  it('should handle nested template', function () {
    var res = (0, _parser.parseComponent)('\n      <template>\n        <div><template v-if="ok">hi</template></div>\n      </template>\n    ');
    expect(res.template.content.trim()).toBe('<div><template v-if="ok">hi</template></div>');
  });

  it('pad content', function () {
    var content = '\n      <template>\n        <div></div>\n      </template>\n      <script>\n        export default {}\n      </script>\n      <style>\n        h1 { color: red }\n      </style>\n';
    var padDefault = (0, _parser.parseComponent)(content.trim(), { pad: true });
    var padLine = (0, _parser.parseComponent)(content.trim(), { pad: 'line' });
    var padSpace = (0, _parser.parseComponent)(content.trim(), { pad: 'space' });

    expect(padDefault.script.content).toBe(Array(3 + 1).join('//\n') + '\nexport default {}\n');
    expect(padDefault.styles[0].content).toBe(Array(6 + 1).join('\n') + '\nh1 { color: red }\n');
    expect(padLine.script.content).toBe(Array(3 + 1).join('//\n') + '\nexport default {}\n');
    expect(padLine.styles[0].content).toBe(Array(6 + 1).join('\n') + '\nh1 { color: red }\n');
    expect(padSpace.script.content).toBe('<template>\n        <div></div>\n      </template>\n      <script>'.replace(/./g, ' ') + '\nexport default {}\n');
    expect(padSpace.styles[0].content).toBe('<template>\n        <div></div>\n      </template>\n      <script>\n        export default {}\n      </script>\n      <style>'.replace(/./g, ' ') + '\nh1 { color: red }\n');
  });

  it('should handle template blocks with lang as special text', function () {
    var res = (0, _parser.parseComponent)('\n      <template lang="pug">\n        div\n          h1(v-if=\'1 < 2\') hello\n      </template>\n    ');
    expect(res.template.content.trim()).toBe('div\n  h1(v-if=\'1 < 2\') hello');
  });

  it('should handle component contains "<" only', function () {
    var res = (0, _parser.parseComponent)('\n      <template>\n        <span><</span>\n      </template>\n    ');
    expect(res.template.content.trim()).toBe('<span><</span>');
  });

  it('should handle custom blocks without parsing them', function () {
    var res = (0, _parser.parseComponent)('\n      <template>\n        <div></div>\n      </template>\n      <example name="simple">\n        <my-button ref="button">Hello</my-button>\n      </example>\n      <example name="with props">\n        <my-button color="red">Hello</my-button>\n      </example>\n      <test name="simple" foo="bar">\n      export default function simple (vm) {\n        describe(\'Hello\', () => {\n          it(\'should display Hello\', () => {\n            this.vm.$refs.button.$el.innerText.should.equal(\'Hello\')\n          }))\n        }))\n      }\n      </test>\n    ');
    expect(res.customBlocks.length).toBe(3);

    var simpleExample = res.customBlocks[0];
    expect(simpleExample.type).toBe('example');
    expect(simpleExample.content.trim()).toBe('<my-button ref="button">Hello</my-button>');
    expect(simpleExample.attrs.name).toBe('simple');

    var withProps = res.customBlocks[1];
    expect(withProps.type).toBe('example');
    expect(withProps.content.trim()).toBe('<my-button color="red">Hello</my-button>');
    expect(withProps.attrs.name).toBe('with props');

    var simpleTest = res.customBlocks[2];
    expect(simpleTest.type).toBe('test');
    expect(simpleTest.content.trim()).toBe('export default function simple (vm) {\n  describe(\'Hello\', () => {\n    it(\'should display Hello\', () => {\n      this.vm.$refs.button.$el.innerText.should.equal(\'Hello\')\n    }))\n  }))\n}');
    expect(simpleTest.attrs.name).toBe('simple');
    expect(simpleTest.attrs.foo).toBe('bar');
  });

  // Regression #4289
  it('accepts nested template tag', function () {
    var raw = '<div>\n      <template v-if="true === true">\n        <section class="section">\n          <div class="container">\n            Should be shown\n          </div>\n        </section>\n      </template>\n      <template v-else>\n        <p>Should not be shown</p>\n      </template>\n    </div>';
    var res = (0, _parser.parseComponent)('<template>' + raw + '</template>');
    expect(res.template.content.trim()).toBe(raw);
  });

  it('should not hang on trailing text', function () {
    var res = (0, _parser.parseComponent)('<template>hi</');
    expect(res.template.content).toBe('hi');
  });
});

