'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Component slot', function () {
  var vm = void 0,
      child = void 0;
  function mount(options) {
    vm = new _vue2.default({
      data: {
        msg: 'parent message'
      },
      template: '<div><test>' + (options.parentContent || '') + '</test></div>',
      components: {
        test: {
          template: options.childTemplate,
          data: function data() {
            return {
              msg: 'child message'
            };
          }
        }
      }
    }).$mount();
    child = vm.$children[0];
  }

  it('no content', function () {
    mount({
      childTemplate: '<div><slot></slot></div>'
    });
    expect(child.$el.childNodes.length).toBe(0);
  });

  it('default slot', function (done) {
    mount({
      childTemplate: '<div><slot></slot></div>',
      parentContent: '<p>{{ msg }}</p>'
    });
    expect(child.$el.tagName).toBe('DIV');
    expect(child.$el.children[0].tagName).toBe('P');
    expect(child.$el.children[0].textContent).toBe('parent message');
    vm.msg = 'changed';
    waitForUpdate(function () {
      expect(child.$el.children[0].textContent).toBe('changed');
    }).then(done);
  });

  it('named slot', function (done) {
    mount({
      childTemplate: '<div><slot name="test"></slot></div>',
      parentContent: '<p slot="test">{{ msg }}</p>'
    });
    expect(child.$el.tagName).toBe('DIV');
    expect(child.$el.children[0].tagName).toBe('P');
    expect(child.$el.children[0].textContent).toBe('parent message');
    vm.msg = 'changed';
    waitForUpdate(function () {
      expect(child.$el.children[0].textContent).toBe('changed');
    }).then(done);
  });

  it('named slot with 0 as a number', function (done) {
    mount({
      childTemplate: '<div><slot :name="0"></slot></div>',
      parentContent: '<p :slot="0">{{ msg }}</p>'
    });
    expect(child.$el.tagName).toBe('DIV');
    expect(child.$el.children[0].tagName).toBe('P');
    expect(child.$el.children[0].textContent).toBe('parent message');
    vm.msg = 'changed';
    waitForUpdate(function () {
      expect(child.$el.children[0].textContent).toBe('changed');
    }).then(done);
  });

  it('fallback content', function () {
    mount({
      childTemplate: '<div><slot><p>{{msg}}</p></slot></div>'
    });
    expect(child.$el.children[0].tagName).toBe('P');
    expect(child.$el.textContent).toBe('child message');
  });

  it('fallback content with multiple named slots', function () {
    mount({
      childTemplate: '\n        <div>\n          <slot name="a"><p>fallback a</p></slot>\n          <slot name="b">fallback b</slot>\n        </div>\n      ',
      parentContent: '<p slot="b">slot b</p>'
    });
    expect(child.$el.children.length).toBe(2);
    expect(child.$el.children[0].textContent).toBe('fallback a');
    expect(child.$el.children[1].textContent).toBe('slot b');
  });

  it('fallback content with mixed named/unnamed slots', function () {
    mount({
      childTemplate: '\n        <div>\n          <slot><p>fallback a</p></slot>\n          <slot name="b">fallback b</slot>\n        </div>\n      ',
      parentContent: '<p slot="b">slot b</p>'
    });
    expect(child.$el.children.length).toBe(2);
    expect(child.$el.children[0].textContent).toBe('fallback a');
    expect(child.$el.children[1].textContent).toBe('slot b');
  });

  it('selector matching multiple elements', function () {
    mount({
      childTemplate: '<div><slot name="t"></slot></div>',
      parentContent: '<p slot="t">1</p><div></div><p slot="t">2</p>'
    });
    expect(child.$el.innerHTML).toBe('<p>1</p><p>2</p>');
  });

  it('default content should only render parts not selected', function () {
    mount({
      childTemplate: '\n        <div>\n          <slot name="a"></slot>\n          <slot></slot>\n          <slot name="b"></slot>\n        </div>\n      ',
      parentContent: '<div>foo</div><p slot="a">1</p><p slot="b">2</p>'
    });
    expect(child.$el.innerHTML).toBe('<p>1</p> <div>foo</div> <p>2</p>');
  });

  it('name should only match children', function () {
    mount({
      childTemplate: '\n        <div>\n          <slot name="a"><p>fallback a</p></slot>\n          <slot name="b"><p>fallback b</p></slot>\n          <slot name="c"><p>fallback c</p></slot>\n        </div>\n      ',
      parentContent: '\n        \'<p slot="b">select b</p>\n        \'<span><p slot="b">nested b</p></span>\n        \'<span><p slot="c">nested c</p></span>\n      '
    });
    expect(child.$el.children.length).toBe(3);
    expect(child.$el.children[0].textContent).toBe('fallback a');
    expect(child.$el.children[1].textContent).toBe('select b');
    expect(child.$el.children[2].textContent).toBe('fallback c');
  });

  it('should accept expressions in slot attribute and slot names', function () {
    mount({
      childTemplate: '<div><slot :name="\'a\'"></slot></div>',
      parentContent: '<p>one</p><p :slot="\'a\'">two</p>'
    });
    expect(child.$el.innerHTML).toBe('<p>two</p>');
  });

  it('slot inside v-if', function (done) {
    var vm = new _vue2.default({
      data: {
        a: 1,
        b: 2,
        show: true
      },
      template: '<test :show="show"><p slot="b">{{b}}</p><p>{{a}}</p></test>',
      components: {
        test: {
          props: ['show'],
          template: '<div v-if="show"><slot></slot><slot name="b"></slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toBe('12');
    vm.a = 2;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('22');
      vm.show = false;
    }).then(function () {
      expect(vm.$el.textContent).toBe('');
      vm.show = true;
      vm.a = 3;
    }).then(function () {
      expect(vm.$el.textContent).toBe('32');
    }).then(done);
  });

  it('slot inside v-for', function () {
    mount({
      childTemplate: '<div><slot v-for="i in 3" :name="i"></slot></div>',
      parentContent: '<p v-for="i in 3" :slot="i">{{ i - 1 }}</p>'
    });
    expect(child.$el.innerHTML).toBe('<p>0</p><p>1</p><p>2</p>');
  });

  it('nested slots', function (done) {
    var vm = new _vue2.default({
      template: '<test><test2><p>{{ msg }}</p></test2></test>',
      data: {
        msg: 'foo'
      },
      components: {
        test: {
          template: '<div><slot></slot></div>'
        },
        test2: {
          template: '<div><slot></slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<div><p>foo</p></div>');
    vm.msg = 'bar';
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('<div><p>bar</p></div>');
    }).then(done);
  });

  it('v-if on inserted content', function (done) {
    var vm = new _vue2.default({
      template: '<test><p v-if="ok">{{ msg }}</p></test>',
      data: {
        ok: true,
        msg: 'hi'
      },
      components: {
        test: {
          template: '<div><slot>fallback</slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<p>hi</p>');
    vm.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('fallback');
      vm.ok = true;
      vm.msg = 'bye';
    }).then(function () {
      expect(vm.$el.innerHTML).toBe('<p>bye</p>');
    }).then(done);
  });

  it('template slot', function () {
    var vm = new _vue2.default({
      template: '<test><template slot="test">hello</template></test>',
      components: {
        test: {
          template: '<div><slot name="test"></slot> world</div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('hello world');
  });

  it('combined with v-for', function () {
    var vm = new _vue2.default({
      template: '<div><test v-for="i in 3" :key="i">{{ i }}</test></div>',
      components: {
        test: {
          template: '<div><slot></slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<div>1</div><div>2</div><div>3</div>');
  });

  it('inside template v-if', function () {
    mount({
      childTemplate: '\n        <div>\n          <template v-if="true"><slot></slot></template>\n        </div>\n      ',
      parentContent: 'foo'
    });
    expect(child.$el.innerHTML).toBe('foo');
  });

  it('default slot should use fallback content if has only whitespace', function () {
    mount({
      childTemplate: '\n        <div>\n          <slot name="first"><p>first slot</p></slot>\n          <slot><p>this is the default slot</p></slot>\n          <slot name="second"><p>second named slot</p></slot>\n        </div>\n      ',
      parentContent: '<div slot="first">1</div> <div slot="second">2</div> <div slot="second">2+</div>'
    });
    expect(child.$el.innerHTML).toBe('<div>1</div> <p>this is the default slot</p> <div>2</div><div>2+</div>');
  });

  it('programmatic access to $slots', function () {
    var vm = new _vue2.default({
      template: '<test><p slot="a">A</p><div>C</div><p slot="b">B</p></test>',
      components: {
        test: {
          render: function render() {
            expect(this.$slots.a.length).toBe(1);
            expect(this.$slots.a[0].tag).toBe('p');
            expect(this.$slots.a[0].children.length).toBe(1);
            expect(this.$slots.a[0].children[0].text).toBe('A');

            expect(this.$slots.b.length).toBe(1);
            expect(this.$slots.b[0].tag).toBe('p');
            expect(this.$slots.b[0].children.length).toBe(1);
            expect(this.$slots.b[0].children[0].text).toBe('B');

            expect(this.$slots.default.length).toBe(1);
            expect(this.$slots.default[0].tag).toBe('div');
            expect(this.$slots.default[0].children.length).toBe(1);
            expect(this.$slots.default[0].children[0].text).toBe('C');

            return this.$slots.default[0];
          }
        }
      }
    }).$mount();
    expect(vm.$el.tagName).toBe('DIV');
    expect(vm.$el.textContent).toBe('C');
  });

  it('warn if user directly returns array', function () {
    new _vue2.default({
      template: '<test><div></div></test>',
      components: {
        test: {
          render: function render() {
            return this.$slots.default;
          }
        }
      }
    }).$mount();
    expect('Render function should return a single root node').toHaveBeenWarned();
  });

  // #3254
  it('should not keep slot name when passed further down', function () {
    var vm = new _vue2.default({
      template: '<test><span slot="foo">foo</span></test>',
      components: {
        test: {
          template: '<child><slot name="foo"></slot></child>',
          components: {
            child: {
              template: '\n                <div>\n                  <div class="default"><slot></slot></div>\n                  <div class="named"><slot name="foo"></slot></div>\n                </div>\n              '
            }
          }
        }
      }
    }).$mount();
    expect(vm.$el.querySelector('.default').textContent).toBe('foo');
    expect(vm.$el.querySelector('.named').textContent).toBe('');
  });

  it('should not keep slot name when passed further down (nested)', function () {
    var vm = new _vue2.default({
      template: '<wrap><test><span slot="foo">foo</span></test></wrap>',
      components: {
        wrap: {
          template: '<div><slot></slot></div>'
        },
        test: {
          template: '<child><slot name="foo"></slot></child>',
          components: {
            child: {
              template: '\n                <div>\n                  <div class="default"><slot></slot></div>\n                  <div class="named"><slot name="foo"></slot></div>\n                </div>\n              '
            }
          }
        }
      }
    }).$mount();
    expect(vm.$el.querySelector('.default').textContent).toBe('foo');
    expect(vm.$el.querySelector('.named').textContent).toBe('');
  });

  it('should not keep slot name when passed further down (functional)', function () {
    var child = {
      template: '\n        <div>\n          <div class="default"><slot></slot></div>\n          <div class="named"><slot name="foo"></slot></div>\n        </div>\n      '
    };

    var vm = new _vue2.default({
      template: '<test><span slot="foo">foo</span></test>',
      components: {
        test: {
          functional: true,
          render: function render(h, ctx) {
            var slots = ctx.slots();
            return h(child, slots.foo);
          }
        }
      }
    }).$mount();
    expect(vm.$el.querySelector('.default').textContent).toBe('foo');
    expect(vm.$el.querySelector('.named').textContent).toBe('');
  });

  // #3400
  it('named slots should be consistent across re-renders', function (done) {
    var vm = new _vue2.default({
      template: '\n        <comp>\n          <div slot="foo">foo</div>\n        </comp>\n      ',
      components: {
        comp: {
          data: function data() {
            return { a: 1 };
          },

          template: '<div><slot name="foo"></slot>{{ a }}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toBe('foo1');
    vm.$children[0].a = 2;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('foo2');
    }).then(done);
  });

  // #3437
  it('should correctly re-create components in slot', function (done) {
    var calls = [];
    var vm = new _vue2.default({
      template: '\n        <comp ref="child">\n          <div slot="foo">\n            <child></child>\n          </div>\n        </comp>\n      ',
      components: {
        comp: {
          data: function data() {
            return { ok: true };
          },

          template: '<div><slot name="foo" v-if="ok"></slot></div>'
        },
        child: {
          template: '<div>child</div>',
          created: function created() {
            calls.push(1);
          },
          destroyed: function destroyed() {
            calls.push(2);
          }
        }
      }
    }).$mount();

    expect(calls).toEqual([1]);
    vm.$refs.child.ok = false;
    waitForUpdate(function () {
      expect(calls).toEqual([1, 2]);
      vm.$refs.child.ok = true;
    }).then(function () {
      expect(calls).toEqual([1, 2, 1]);
      vm.$refs.child.ok = false;
    }).then(function () {
      expect(calls).toEqual([1, 2, 1, 2]);
    }).then(done);
  });

  it('warn duplicate slots', function () {
    new _vue2.default({
      template: '<div>\n        <test>\n          <div>foo</div>\n          <div slot="a">bar</div>\n        </test>\n      </div>',
      components: {
        test: {
          template: '<div>\n            <slot></slot><slot></slot>\n            <div v-for="i in 3"><slot name="a"></slot></div>\n          </div>'
        }
      }
    }).$mount();
    expect('Duplicate presence of slot "default"').toHaveBeenWarned();
    expect('Duplicate presence of slot "a"').toHaveBeenWarned();
  });

  it('should not warn valid conditional slots', function () {
    new _vue2.default({
      template: '<div>\n        <test>\n          <div>foo</div>\n        </test>\n      </div>',
      components: {
        test: {
          template: '<div>\n            <slot v-if="true"></slot>\n            <slot v-else></slot>\n          </div>'
        }
      }
    }).$mount();
    expect('Duplicate presence of slot "default"').not.toHaveBeenWarned();
  });

  // #3518
  it('events should not break when slot is toggled by v-if', function (done) {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      template: '<test><div class="click" @click="test">hi</div></test>',
      methods: {
        test: spy
      },
      components: {
        test: {
          data: function data() {
            return {
              toggle: true
            };
          },
          template: '<div v-if="toggle"><slot></slot></div>'
        }
      }
    }).$mount();

    expect(vm.$el.textContent).toBe('hi');
    vm.$children[0].toggle = false;
    waitForUpdate(function () {
      vm.$children[0].toggle = true;
    }).then(function () {
      triggerEvent(vm.$el.querySelector('.click'), 'click');
      expect(spy).toHaveBeenCalled();
    }).then(done);
  });

  it('renders static tree with text', function () {
    var vm = new _vue2.default({
      template: '<div><test><template><div></div>Hello<div></div></template></test></div>',
      components: {
        test: {
          template: '<div><slot></slot></div>'
        }
      }
    });
    vm.$mount();
    expect('Error when rendering root').not.toHaveBeenWarned();
  });

  // #3872
  it('functional component as slot', function () {
    var vm = new _vue2.default({
      template: '\n        <parent>\n          <child>one</child>\n          <child slot="a">two</child>\n        </parent>\n      ',
      components: {
        parent: {
          template: '<div><slot name="a"></slot><slot></slot></div>'
        },
        child: {
          functional: true,
          render: function render(h, _ref) {
            var slots = _ref.slots;

            return h('div', slots().default);
          }
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML.trim()).toBe('<div>two</div><div>one</div>');
  });

  // #4209
  it('slot of multiple text nodes should not be infinitely merged', function (done) {
    var wrap = {
      template: '<inner ref="inner">foo<slot></slot></inner>',
      components: {
        inner: {
          data: function data() {
            return { a: 1 };
          },
          template: '<div>{{a}}<slot></slot></div>'
        }
      }
    };
    var vm = new _vue2.default({
      template: '<wrap ref="wrap">bar</wrap>',
      components: { wrap: wrap }
    }).$mount();

    expect(vm.$el.textContent).toBe('1foobar');
    vm.$refs.wrap.$refs.inner.a++;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('2foobar');
    }).then(done);
  });

  // #4315
  it('functional component passing slot content to stateful child component', function (done) {
    var ComponentWithSlots = {
      render: function render(h) {
        return h('div', this.$slots.slot1);
      }
    };

    var FunctionalComp = {
      functional: true,
      render: function render(h) {
        return h(ComponentWithSlots, [h('span', { slot: 'slot1' }, 'foo')]);
      }
    };

    var vm = new _vue2.default({
      data: { n: 1 },
      render: function render(h) {
        return h('div', [this.n, h(FunctionalComp)]);
      }
    }).$mount();

    expect(vm.$el.textContent).toBe('1foo');
    vm.n++;
    waitForUpdate(function () {
      // should not lose named slot
      expect(vm.$el.textContent).toBe('2foo');
    }).then(done);
  });

  it('the elements of slot should be updated correctly', function (done) {
    var vm = new _vue2.default({
      data: { n: 1 },
      template: '<div><test><span v-for="i in n" :key="i">{{ i }}</span><input value="a"/></test></div>',
      components: {
        test: {
          template: '<div><slot></slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<div><span>1</span><input value="a"></div>');
    var input = vm.$el.querySelector('input');
    input.value = 'b';
    vm.n++;
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('<div><span>1</span><span>2</span><input value="a"></div>');
      expect(vm.$el.querySelector('input')).toBe(input);
      expect(vm.$el.querySelector('input').value).toBe('b');
    }).then(done);
  });

  // GitHub issue #5888
  it('should resolve correctly slot with keep-alive', function () {
    var vm = new _vue2.default({
      template: '\n      <div>\n        <container>\n          <keep-alive slot="foo">\n            <child></child>\n          </keep-alive>\n        </container>\n      </div>\n      ',
      components: {
        container: {
          template: '<div><slot>default</slot><slot name="foo">named</slot></div>'
        },
        child: {
          template: '<span>foo</span>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<div>default<span>foo</span></div>');
  });

  // #6372, #6915
  it('should handle nested components in slots properly', function (done) {
    var TestComponent = {
      template: '\n        <component :is="toggleEl ? \'b\' : \'i\'">\n          <slot />\n        </component>\n      ',
      data: function data() {
        return {
          toggleEl: true
        };
      }
    };

    var vm = new _vue2.default({
      template: '\n        <div>\n          <test-component ref="test">\n            <div>\n              <foo/>\n            </div>\n            <bar>\n              <foo/>\n            </bar>\n          </test-component>\n        </div>\n      ',
      components: {
        TestComponent: TestComponent,
        foo: {
          template: '<div>foo</div>'
        },
        bar: {
          template: '<div>bar<slot/></div>'
        }
      }
    }).$mount();

    expect(vm.$el.innerHTML).toBe('<b><div><div>foo</div></div> <div>bar<div>foo</div></div></b>');

    vm.$refs.test.toggleEl = false;
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('<i><div><div>foo</div></div> <div>bar<div>foo</div></div></i>');
    }).then(done);
  });

  it('should preserve slot attribute if not absorbed by a Vue component', function () {
    var vm = new _vue2.default({
      template: '\n        <div>\n          <div slot="foo"></div>\n        </div>\n      '
    }).$mount();
    expect(vm.$el.children[0].getAttribute('slot')).toBe('foo');
  });

  it('passing a slot down as named slot', function () {
    var Bar = {
      template: '<div class="bar"><slot name="foo"/></div>'
    };

    var Foo = {
      components: { Bar: Bar },
      template: '<div class="foo"><bar><slot slot="foo"/></bar></div>'
    };

    var vm = new _vue2.default({
      components: { Foo: Foo },
      template: '<div><foo>hello</foo></div>'
    }).$mount();

    expect(vm.$el.innerHTML).toBe('<div class="foo"><div class="bar">hello</div></div>');
  });

  it('fallback content for named template slot', function () {
    var Bar = {
      template: '<div class="bar"><slot name="foo">fallback</slot></div>'
    };

    var Foo = {
      components: { Bar: Bar },
      template: '<div class="foo"><bar><template slot="foo"/><slot/></template></bar></div>'
    };

    var vm = new _vue2.default({
      components: { Foo: Foo },
      template: '<div><foo></foo></div>'
    }).$mount();

    expect(vm.$el.innerHTML).toBe('<div class="foo"><div class="bar">fallback</div></div>');
  });

  // #7106
  it('should not lose functional slot across renders', function (done) {
    var One = {
      data: function data() {
        return {
          foo: true
        };
      },
      render: function render(h) {
        this.foo;
        return h('div', this.$slots.slot);
      }
    };

    var Two = {
      render: function render(h) {
        return h('span', this.$slots.slot);
      }
    };

    var Three = {
      functional: true,
      render: function render(h, _ref2) {
        var children = _ref2.children;
        return h('span', children);
      }
    };

    var vm = new _vue2.default({
      template: '\n        <div>\n          <one ref="one">\n            <two slot="slot">\n              <three slot="slot">hello</three>\n            </two>\n          </one>\n        </div>\n      ',
      components: { One: One, Two: Two, Three: Three }
    }).$mount();

    expect(vm.$el.textContent).toBe('hello');
    // trigger re-render of <one>
    vm.$refs.one.foo = false;
    waitForUpdate(function () {
      // should still be there
      expect(vm.$el.textContent).toBe('hello');
    }).then(done);
  });

  it('should allow passing named slots as raw children down multiple layers of functional component', function () {
    var CompB = {
      functional: true,
      render: function render(h, _ref3) {
        var slots = _ref3.slots;

        return slots().foo;
      }
    };

    var CompA = {
      functional: true,
      render: function render(h, _ref4) {
        var children = _ref4.children;

        return h(CompB, children);
      }
    };

    var vm = new _vue2.default({
      components: {
        CompA: CompA
      },
      template: '\n        <div>\n          <comp-a>\n            <span slot="foo">foo</span>\n          </comp-a>\n        </div>\n      '
    }).$mount();

    expect(vm.$el.textContent).toBe('foo');
  });
});

