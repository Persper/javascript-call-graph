'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Options data', function () {
  it('should proxy and be reactive', function (done) {
    var data = { msg: 'foo' };
    var vm = new _vue2.default({
      data: data,
      template: '<div>{{ msg }}</div>'
    }).$mount();
    expect(vm.$data).toEqual({ msg: 'foo' });
    expect(vm.$data).toBe(data);
    data.msg = 'bar';
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('bar');
    }).then(done);
  });

  it('should merge data properly', function () {
    var Test = _vue2.default.extend({
      data: function data() {
        return { a: 1 };
      }
    });
    var vm = new Test({
      data: { b: 2 }
    });
    expect(vm.a).toBe(1);
    expect(vm.b).toBe(2);
    // no instance data
    vm = new Test();
    expect(vm.a).toBe(1);
    // no child-val
    var Extended = Test.extend({});
    vm = new Extended();
    expect(vm.a).toBe(1);
    // recursively merge objects
    var WithObject = _vue2.default.extend({
      data: function data() {
        return {
          obj: {
            a: 1
          }
        };
      }
    });
    vm = new WithObject({
      data: {
        obj: {
          b: 2
        }
      }
    });
    expect(vm.obj.a).toBe(1);
    expect(vm.obj.b).toBe(2);
  });

  it('should warn non-function during extend', function () {
    _vue2.default.extend({
      data: { msg: 'foo' }
    });
    expect('The "data" option should be a function').toHaveBeenWarned();
  });

  it('should warn non object return', function () {
    new _vue2.default({
      data: function data() {}
    });
    expect('data functions should return an object').toHaveBeenWarned();
  });

  it('should warn replacing root $data', function () {
    var vm = new _vue2.default({
      data: {}
    });
    vm.$data = {};
    expect('Avoid replacing instance root $data').toHaveBeenWarned();
  });

  it('should have access to props', function () {
    var Test = {
      props: ['a'],
      render: function render() {},
      data: function data() {
        return {
          b: this.a
        };
      }
    };
    var vm = new _vue2.default({
      template: '<test ref="test" :a="1"></test>',
      components: { Test: Test }
    }).$mount();
    expect(vm.$refs.test.b).toBe(1);
  });

  it('props should not be reactive', function (done) {
    var calls = 0;
    var vm = new _vue2.default({
      template: '<child :msg="msg"></child>',
      data: {
        msg: 'hello'
      },
      beforeUpdate: function beforeUpdate() {
        calls++;
      },

      components: {
        child: {
          template: '<span>{{ localMsg }}</span>',
          props: ['msg'],
          data: function data() {
            return { localMsg: this.msg };
          },

          computed: {
            computedMsg: function computedMsg() {
              return this.msg + ' world';
            }
          }
        }
      }
    }).$mount();
    var child = vm.$children[0];
    vm.msg = 'hi';
    waitForUpdate(function () {
      expect(child.localMsg).toBe('hello');
      expect(child.computedMsg).toBe('hi world');
      expect(calls).toBe(1);
    }).then(done);
  });

  it('should have access to methods', function () {
    var vm = new _vue2.default({
      methods: {
        get: function get() {
          return { a: 1 };
        }
      },
      data: function data() {
        return this.get();
      }
    });
    expect(vm.a).toBe(1);
  });

  it('should be called with this', function () {
    var vm = new _vue2.default({
      template: '<div><child></child></div>',
      provide: { foo: 1 },
      components: {
        child: {
          template: '<span>{{bar}}</span>',
          inject: ['foo'],
          data: function data(_ref) {
            var foo = _ref.foo;

            return { bar: 'foo:' + foo };
          }
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<span>foo:1</span>');
  });

  it('should be called with vm as first argument when merged', function () {
    var superComponent = {
      data: function data(_ref2) {
        var foo = _ref2.foo;
        return { ext: 'ext:' + foo };
      }
    };
    var mixins = [{
      data: function data(_ref3) {
        var foo = _ref3.foo;
        return { mixin1: 'm1:' + foo };
      }
    }, {
      data: function data(_ref4) {
        var foo = _ref4.foo;
        return { mixin2: 'm2:' + foo };
      }
    }];
    var vm = new _vue2.default({
      template: '<div><child></child></div>',
      provide: { foo: 1 },
      components: {
        child: {
          extends: superComponent,
          mixins: mixins,
          template: '<span>{{bar}}-{{ext}}-{{mixin1}}-{{mixin2}}</span>',
          inject: ['foo'],
          data: function data(_ref5) {
            var foo = _ref5.foo;
            return { bar: 'foo:' + foo };
          }
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('<span>foo:1-ext:1-m1:1-m2:1</span>');
  });
});

