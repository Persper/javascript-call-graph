'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

var _env = require('core/util/env');

var _testObjectOption = require('../../../helpers/test-object-option');

var _testObjectOption2 = _interopRequireDefault(_testObjectOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Options props', function () {
  (0, _testObjectOption2.default)('props');

  it('array syntax', function (done) {
    var vm = new _vue2.default({
      data: {
        b: 'bar'
      },
      template: '<test v-bind:b="b" ref="child"></test>',
      components: {
        test: {
          props: ['b'],
          template: '<div>{{b}}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('bar');
    vm.b = 'baz';
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('baz');
      vm.$refs.child.b = 'qux';
    }).then(function () {
      expect(vm.$el.innerHTML).toBe('qux');
      expect('Avoid mutating a prop directly').toHaveBeenWarned();
    }).then(done);
  });

  it('object syntax', function (done) {
    var vm = new _vue2.default({
      data: {
        b: 'bar'
      },
      template: '<test v-bind:b="b" ref="child"></test>',
      components: {
        test: {
          props: { b: String },
          template: '<div>{{b}}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.innerHTML).toBe('bar');
    vm.b = 'baz';
    waitForUpdate(function () {
      expect(vm.$el.innerHTML).toBe('baz');
      vm.$refs.child.b = 'qux';
    }).then(function () {
      expect(vm.$el.innerHTML).toBe('qux');
      expect('Avoid mutating a prop directly').toHaveBeenWarned();
    }).then(done);
  });

  it('warn mixed syntax', function () {
    new _vue2.default({
      props: [{ b: String }]
    });
    expect('props must be strings when using array syntax').toHaveBeenWarned();
  });

  it('default values', function () {
    var vm = new _vue2.default({
      data: {
        b: undefined
      },
      template: '<test :b="b"></test>',
      components: {
        test: {
          props: {
            a: {
              default: 'A' // absent
            },
            b: {
              default: 'B' // undefined
            }
          },
          template: '<div>{{a}}{{b}}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toBe('AB');
  });

  it('default value reactivity', function (done) {
    var vm = new _vue2.default({
      props: {
        a: {
          default: function _default() {
            return { b: 1 };
          }
        }
      },
      propsData: {
        a: undefined
      },
      template: '<div>{{ a.b }}</div>'
    }).$mount();
    expect(vm.$el.textContent).toBe('1');
    vm.a.b = 2;
    waitForUpdate(function () {
      expect(vm.$el.textContent).toBe('2');
    }).then(done);
  });

  it('default value Function', function () {
    var func = function func() {
      return 132;
    };
    var vm = new _vue2.default({
      props: {
        a: {
          type: Function,
          default: func
        }
      },
      propsData: {
        a: undefined
      }
    });
    expect(vm.a).toBe(func);
  });

  it('warn object/array default values', function () {
    new _vue2.default({
      props: {
        a: {
          default: { b: 1 }
        }
      },
      propsData: {
        a: undefined
      }
    });
    expect('Props with type Object/Array must use a factory function').toHaveBeenWarned();
  });

  it('warn missing required', function () {
    new _vue2.default({
      template: '<test></test>',
      components: {
        test: {
          props: { a: { required: true } },
          template: '<div>{{a}}</div>'
        }
      }
    }).$mount();
    expect('Missing required prop: "a"').toHaveBeenWarned();
  });

  describe('assertions', function () {
    function makeInstance(value, type, validator, required) {
      return new _vue2.default({
        template: '<test :test="val"></test>',
        data: {
          val: value
        },
        components: {
          test: {
            template: '<div></div>',
            props: {
              test: {
                type: type,
                validator: validator,
                required: required
              }
            }
          }
        }
      }).$mount();
    }

    it('string', function () {
      makeInstance('hello', String);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(123, String);
      expect('Expected String').toHaveBeenWarned();
    });

    it('number', function () {
      makeInstance(123, Number);
      expect(console.error.calls.count()).toBe(0);
      makeInstance('123', Number);
      expect('Expected Number').toHaveBeenWarned();
    });

    it('boolean', function () {
      makeInstance(true, Boolean);
      expect(console.error.calls.count()).toBe(0);
      makeInstance('123', Boolean);
      expect('Expected Boolean').toHaveBeenWarned();
    });

    it('function', function () {
      makeInstance(function () {}, Function);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(123, Function);
      expect('Expected Function').toHaveBeenWarned();
    });

    it('object', function () {
      makeInstance({}, Object);
      expect(console.error.calls.count()).toBe(0);
      makeInstance([], Object);
      expect('Expected Object').toHaveBeenWarned();
    });

    it('array', function () {
      makeInstance([], Array);
      expect(console.error.calls.count()).toBe(0);
      makeInstance({}, Array);
      expect('Expected Array').toHaveBeenWarned();
    });

    it('primitive wrapper objects', function () {
      /* eslint-disable no-new-wrappers */
      makeInstance(new String('s'), String);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(new Number(1), Number);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(new Boolean(true), Boolean);
      expect(console.error.calls.count()).toBe(0);
      /* eslint-enable no-new-wrappers */
    });

    if (_env.hasSymbol) {
      it('symbol', function () {
        makeInstance(Symbol('foo'), Symbol);
        expect(console.error.calls.count()).toBe(0);
        makeInstance({}, Symbol);
        expect('Expected Symbol').toHaveBeenWarned();
      });
    }

    it('custom constructor', function () {
      function Class() {}
      makeInstance(new Class(), Class);
      expect(console.error.calls.count()).toBe(0);
      makeInstance({}, Class);
      expect('type check failed').toHaveBeenWarned();
    });

    it('multiple types', function () {
      makeInstance([], [Array, Number, Boolean]);
      expect(console.error.calls.count()).toBe(0);
      makeInstance({}, [Array, Number, Boolean]);
      expect('Expected Array, Number, Boolean, got Object').toHaveBeenWarned();
    });

    it('custom validator', function () {
      makeInstance(123, null, function (v) {
        return v === 123;
      });
      expect(console.error.calls.count()).toBe(0);
      makeInstance(123, null, function (v) {
        return v === 234;
      });
      expect('custom validator check failed').toHaveBeenWarned();
    });

    it('type check + custom validator', function () {
      makeInstance(123, Number, function (v) {
        return v === 123;
      });
      expect(console.error.calls.count()).toBe(0);
      makeInstance(123, Number, function (v) {
        return v === 234;
      });
      expect('custom validator check failed').toHaveBeenWarned();
      makeInstance(123, String, function (v) {
        return v === 123;
      });
      expect('Expected String').toHaveBeenWarned();
    });

    it('multiple types + custom validator', function () {
      makeInstance(123, [Number, String, Boolean], function (v) {
        return v === 123;
      });
      expect(console.error.calls.count()).toBe(0);
      makeInstance(123, [Number, String, Boolean], function (v) {
        return v === 234;
      });
      expect('custom validator check failed').toHaveBeenWarned();
      makeInstance(123, [String, Boolean], function (v) {
        return v === 123;
      });
      expect('Expected String, Boolean').toHaveBeenWarned();
    });

    it('optional with type + null/undefined', function () {
      makeInstance(undefined, String);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(null, String);
      expect(console.error.calls.count()).toBe(0);
    });

    it('required with type + null/undefined', function () {
      makeInstance(undefined, String, null, true);
      expect(console.error.calls.count()).toBe(1);
      expect('Expected String').toHaveBeenWarned();
      makeInstance(null, Boolean, null, true);
      expect(console.error.calls.count()).toBe(2);
      expect('Expected Boolean').toHaveBeenWarned();
    });

    it('optional prop of any type (type: true or prop: true)', function () {
      makeInstance(1, true);
      expect(console.error.calls.count()).toBe(0);
      makeInstance('any', true);
      expect(console.error.calls.count()).toBe(0);
      makeInstance({}, true);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(undefined, true);
      expect(console.error.calls.count()).toBe(0);
      makeInstance(null, true);
      expect(console.error.calls.count()).toBe(0);
    });
  });

  it('should work with v-bind', function () {
    var vm = new _vue2.default({
      template: '<test v-bind="{ a: 1, b: 2 }"></test>',
      components: {
        test: {
          props: ['a', 'b'],
          template: '<div>{{ a }} {{ b }}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toBe('1 2');
  });

  it('should warn data fields already defined as a prop', function () {
    new _vue2.default({
      template: '<test a="1"></test>',
      components: {
        test: {
          template: '<div></div>',
          data: function data() {
            return { a: 123 };
          },
          props: {
            a: null
          }
        }
      }
    }).$mount();
    expect('already declared as a prop').toHaveBeenWarned();
  });

  it('should warn methods already defined as a prop', function () {
    new _vue2.default({
      template: '<test a="1"></test>',
      components: {
        test: {
          template: '<div></div>',
          props: {
            a: null
          },
          methods: {
            a: function a() {}
          }
        }
      }
    }).$mount();
    expect('Method "a" has already been defined as a prop').toHaveBeenWarned();
    expect('Avoid mutating a prop directly').toHaveBeenWarned();
  });

  it('treat boolean props properly', function () {
    var vm = new _vue2.default({
      template: '<comp ref="child" prop-a prop-b="prop-b"></comp>',
      components: {
        comp: {
          template: '<div></div>',
          props: {
            propA: Boolean,
            propB: Boolean,
            propC: Boolean
          }
        }
      }
    }).$mount();
    expect(vm.$refs.child.propA).toBe(true);
    expect(vm.$refs.child.propB).toBe(true);
    expect(vm.$refs.child.propC).toBe(false);
  });

  it('should respect default value of a Boolean prop', function () {
    var vm = new _vue2.default({
      template: '<test></test>',
      components: {
        test: {
          props: {
            prop: {
              type: Boolean,
              default: true
            }
          },
          template: '<div>{{prop}}</div>'
        }
      }
    }).$mount();
    expect(vm.$el.textContent).toBe('true');
  });

  it('non reactive values passed down as prop should not be converted', function (done) {
    var a = Object.freeze({
      nested: {
        msg: 'hello'
      }
    });
    var parent = new _vue2.default({
      template: '<comp :a="a.nested"></comp>',
      data: {
        a: a
      },
      components: {
        comp: {
          template: '<div></div>',
          props: ['a']
        }
      }
    }).$mount();
    var child = parent.$children[0];
    expect(child.a.msg).toBe('hello');
    expect(child.a.__ob__).toBeUndefined(); // should not be converted
    parent.a = Object.freeze({
      nested: {
        msg: 'yo'
      }
    });
    waitForUpdate(function () {
      expect(child.a.msg).toBe('yo');
      expect(child.a.__ob__).toBeUndefined();
    }).then(done);
  });

  it('should not warn for non-required, absent prop', function () {
    new _vue2.default({
      template: '<test></test>',
      components: {
        test: {
          template: '<div></div>',
          props: {
            prop: {
              type: String
            }
          }
        }
      }
    }).$mount();
    expect(console.error.calls.count()).toBe(0);
  });

  // #3453
  it('should not fire watcher on object/array props when parent re-renders', function (done) {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      data: {
        arr: []
      },
      template: '<test :prop="arr">hi</test>',
      components: {
        test: {
          props: ['prop'],
          watch: {
            prop: spy
          },
          template: '<div><slot></slot></div>'
        }
      }
    }).$mount();
    vm.$forceUpdate();
    waitForUpdate(function () {
      expect(spy).not.toHaveBeenCalled();
    }).then(done);
  });

  // #4090
  it('should not trigger watcher on default value', function (done) {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      template: '<test :value="a" :test="b"></test>',
      data: {
        a: 1,
        b: undefined
      },
      components: {
        test: {
          template: '<div>{{ value }}</div>',
          props: {
            value: { type: Number },
            test: {
              type: Object,
              default: function _default() {
                return {};
              }
            }
          },
          watch: {
            test: spy
          }
        }
      }
    }).$mount();

    vm.a++;
    waitForUpdate(function () {
      expect(spy).not.toHaveBeenCalled();
      vm.b = {};
    }).then(function () {
      expect(spy.calls.count()).toBe(1);
    }).then(function () {
      vm.b = undefined;
    }).then(function () {
      expect(spy.calls.count()).toBe(2);
      vm.a++;
    }).then(function () {
      expect(spy.calls.count()).toBe(2);
    }).then(done);
  });

  it('warn reserved props', function () {
    var specialAttrs = ['key', 'ref', 'slot', 'is', 'slot-scope'];
    new _vue2.default({
      props: specialAttrs
    });
    specialAttrs.forEach(function (attr) {
      expect('"' + attr + '" is a reserved attribute').toHaveBeenWarned();
    });
  });

  it('should consider order when casting [Boolean, String] multi-type props', function () {
    var vm = new _vue2.default({
      template: '<test ref="test" booleanOrString stringOrBoolean />',
      components: {
        test: {
          template: '<div></div>',
          props: {
            booleanOrString: [Boolean, String],
            stringOrBoolean: [String, Boolean]
          }
        }
      }
    }).$mount();
    expect(vm.$refs.test.$props.booleanOrString).toBe(true);
    expect(vm.$refs.test.$props.stringOrBoolean).toBe('');
  });
});

