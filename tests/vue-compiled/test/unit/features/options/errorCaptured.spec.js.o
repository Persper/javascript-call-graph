'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Options errorCaptured', function () {
  var globalSpy = void 0;

  beforeEach(function () {
    globalSpy = _vue2.default.config.errorHandler = jasmine.createSpy();
  });

  afterEach(function () {
    _vue2.default.config.errorHandler = null;
  });

  it('should capture error from child component', function () {
    var spy = jasmine.createSpy();

    var child = void 0;
    var err = void 0;
    var Child = {
      created: function created() {
        child = this;
        err = new Error('child');
        throw err;
      },
      render: function render() {}
    };

    new _vue2.default({
      errorCaptured: spy,
      render: function render(h) {
        return h(Child);
      }
    }).$mount();

    expect(spy).toHaveBeenCalledWith(err, child, 'created hook');
    // should propagate by default
    expect(globalSpy).toHaveBeenCalledWith(err, child, 'created hook');
  });

  it('should be able to render the error in itself', function (done) {
    var child = void 0;
    var Child = {
      created: function created() {
        child = this;
        throw new Error('error from child');
      },
      render: function render() {}
    };

    var vm = new _vue2.default({
      data: {
        error: null
      },
      errorCaptured: function errorCaptured(e, vm, info) {
        expect(vm).toBe(child);
        this.error = e.toString() + ' in ' + info;
      },
      render: function render(h) {
        if (this.error) {
          return h('pre', this.error);
        }
        return h(Child);
      }
    }).$mount();

    waitForUpdate(function () {
      expect(vm.$el.textContent).toContain('error from child');
      expect(vm.$el.textContent).toContain('in created hook');
    }).then(done);
  });

  it('should not propagate to global handler when returning true', function () {
    var spy = jasmine.createSpy();

    var child = void 0;
    var err = void 0;
    var Child = {
      created: function created() {
        child = this;
        err = new Error('child');
        throw err;
      },
      render: function render() {}
    };

    new _vue2.default({
      errorCaptured: function errorCaptured(err, vm, info) {
        spy(err, vm, info);
        return false;
      },

      render: function render(h) {
        return h(Child, {});
      }
    }).$mount();

    expect(spy).toHaveBeenCalledWith(err, child, 'created hook');
    // should not propagate
    expect(globalSpy).not.toHaveBeenCalled();
  });

  it('should propagate to global handler if itself throws error', function () {
    var child = void 0;
    var err = void 0;
    var Child = {
      created: function created() {
        child = this;
        err = new Error('child');
        throw err;
      },
      render: function render() {}
    };

    var err2 = void 0;
    var vm = new _vue2.default({
      errorCaptured: function errorCaptured() {
        err2 = new Error('foo');
        throw err2;
      },

      render: function render(h) {
        return h(Child, {});
      }
    }).$mount();

    expect(globalSpy).toHaveBeenCalledWith(err, child, 'created hook');
    expect(globalSpy).toHaveBeenCalledWith(err2, vm, 'errorCaptured hook');
  });

  it('should work across multiple parents, mixins and extends', function () {
    var calls = [];

    var Child = {
      created: function created() {
        throw new Error('child');
      },
      render: function render() {}
    };

    var ErrorBoundaryBase = {
      errorCaptured: function errorCaptured() {
        calls.push(1);
      }
    };

    var mixin = {
      errorCaptured: function errorCaptured() {
        calls.push(2);
      }
    };

    var ErrorBoundaryExtended = {
      extends: ErrorBoundaryBase,
      mixins: [mixin],
      errorCaptured: function errorCaptured() {
        calls.push(3);
      },

      render: function render(h) {
        return h(Child);
      }
    };

    _vue2.default.config.errorHandler = function () {
      calls.push(5);
    };

    new _vue2.default({
      errorCaptured: function errorCaptured() {
        calls.push(4);
      },

      render: function render(h) {
        return h(ErrorBoundaryExtended);
      }
    }).$mount();

    expect(calls).toEqual([1, 2, 3, 4, 5]);
  });

  it('should work across multiple parents, mixins and extends with return false', function () {
    var calls = [];

    var Child = {
      created: function created() {
        throw new Error('child');
      },
      render: function render() {}
    };

    var ErrorBoundaryBase = {
      errorCaptured: function errorCaptured() {
        calls.push(1);
      }
    };

    var mixin = {
      errorCaptured: function errorCaptured() {
        calls.push(2);
      }
    };

    var ErrorBoundaryExtended = {
      extends: ErrorBoundaryBase,
      mixins: [mixin],
      errorCaptured: function errorCaptured() {
        calls.push(3);
        return false;
      },

      render: function render(h) {
        return h(Child);
      }
    };

    _vue2.default.config.errorHandler = function () {
      calls.push(5);
    };

    new _vue2.default({
      errorCaptured: function errorCaptured() {
        calls.push(4);
      },

      render: function render(h) {
        return h(ErrorBoundaryExtended);
      }
    }).$mount();

    expect(calls).toEqual([1, 2, 3]);
  });
});

