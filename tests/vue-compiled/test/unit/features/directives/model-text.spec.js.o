'use strict';

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

var _env = require('core/util/env');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Directive v-model text', function () {
  it('should update value both ways', function (done) {
    var vm = new _vue2.default({
      data: {
        test: 'b'
      },
      template: '<input v-model="test">'
    }).$mount();
    expect(vm.$el.value).toBe('b');
    vm.test = 'a';
    waitForUpdate(function () {
      expect(vm.$el.value).toBe('a');
      vm.$el.value = 'c';
      triggerEvent(vm.$el, 'input');
      expect(vm.test).toBe('c');
    }).then(done);
  });

  it('should work with space ended expression in v-model', function () {
    var vm = new _vue2.default({
      data: {
        obj: {
          test: 'b'
        }
      },
      template: '<input v-model="obj.test ">'
    }).$mount();

    triggerEvent(vm.$el, 'input');
    expect(vm.obj['test ']).toBe(undefined);
    expect(vm.obj.test).toBe('b');
  });

  it('.lazy modifier', function () {
    var vm = new _vue2.default({
      data: {
        test: 'b'
      },
      template: '<input v-model.lazy="test">'
    }).$mount();
    expect(vm.$el.value).toBe('b');
    expect(vm.test).toBe('b');
    vm.$el.value = 'c';
    triggerEvent(vm.$el, 'input');
    expect(vm.test).toBe('b');
    triggerEvent(vm.$el, 'change');
    expect(vm.test).toBe('c');
  });

  it('.number modifier', function () {
    var vm = new _vue2.default({
      data: {
        test: 1
      },
      template: '<input v-model.number="test">'
    }).$mount();
    expect(vm.test).toBe(1);
    vm.$el.value = '2';
    triggerEvent(vm.$el, 'input');
    expect(vm.test).toBe(2);
    // should let strings pass through
    vm.$el.value = 'f';
    triggerEvent(vm.$el, 'input');
    expect(vm.test).toBe('f');
  });

  it('.trim modifier', function () {
    var vm = new _vue2.default({
      data: {
        test: 'hi'
      },
      template: '<input v-model.trim="test">'
    }).$mount();
    expect(vm.test).toBe('hi');
    vm.$el.value = ' what ';
    triggerEvent(vm.$el, 'input');
    expect(vm.test).toBe('what');
  });

  it('.number focus and typing', function (done) {
    var vm = new _vue2.default({
      data: {
        test: 0,
        update: 0
      },
      template: '<div>' + '<input ref="input" v-model.number="test">{{ update }}' + '<input ref="blur">' + '</div>'
    }).$mount();
    document.body.appendChild(vm.$el);
    vm.$refs.input.focus();
    expect(vm.test).toBe(0);
    vm.$refs.input.value = '1.0';
    triggerEvent(vm.$refs.input, 'input');
    expect(vm.test).toBe(1);
    vm.update++;
    waitForUpdate(function () {
      expect(vm.$refs.input.value).toBe('1.0');
      vm.$refs.blur.focus();
      vm.update++;
    }).then(function () {
      expect(vm.$refs.input.value).toBe('1');
    }).then(done);
  });

  it('.trim focus and typing', function (done) {
    var vm = new _vue2.default({
      data: {
        test: 'abc',
        update: 0
      },
      template: '<div>' + '<input ref="input" v-model.trim="test" type="text">{{ update }}' + '<input ref="blur"/>' + '</div>'
    }).$mount();
    document.body.appendChild(vm.$el);
    vm.$refs.input.focus();
    vm.$refs.input.value = ' abc ';
    triggerEvent(vm.$refs.input, 'input');
    expect(vm.test).toBe('abc');
    vm.update++;
    waitForUpdate(function () {
      expect(vm.$refs.input.value).toBe(' abc ');
      vm.$refs.blur.focus();
      vm.update++;
    }).then(function () {
      expect(vm.$refs.input.value).toBe('abc');
    }).then(done);
  });

  it('multiple inputs', function (done) {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      data: {
        selections: [[1, 2, 3], [4, 5]],
        inputList: [{
          name: 'questionA',
          data: ['a', 'b', 'c']
        }, {
          name: 'questionB',
          data: ['1', '2']
        }]
      },
      watch: {
        selections: spy
      },
      template: '<div>' + '<div v-for="(inputGroup, idx) in inputList">' + '<div>' + '<span v-for="(item, index) in inputGroup.data">' + '<input v-bind:name="item" type="text" v-model.number="selections[idx][index]" v-bind:id="idx+\'-\'+index"/>' + '<label>{{item}}</label>' + '</span>' + '</div>' + '</div>' + '<span ref="rs">{{selections}}</span>' + '</div>'
    }).$mount();
    var inputs = vm.$el.getElementsByTagName('input');
    inputs[1].value = 'test';
    triggerEvent(inputs[1], 'input');
    waitForUpdate(function () {
      expect(spy).toHaveBeenCalled();
      expect(vm.selections).toEqual([[1, 'test', 3], [4, 5]]);
    }).then(done);
  });

  if (_env.isIE9) {
    it('IE9 selectionchange', function (done) {
      var vm = new _vue2.default({
        data: {
          test: 'foo'
        },
        template: '<input v-model="test">'
      }).$mount();
      var input = vm.$el;
      input.value = 'bar';
      document.body.appendChild(input);
      input.focus();
      triggerEvent(input, 'selectionchange');
      waitForUpdate(function () {
        expect(vm.test).toBe('bar');
        input.value = 'a';
        triggerEvent(input, 'selectionchange');
        expect(vm.test).toBe('a');
      }).then(done);
    });
  }

  it('compositionevents', function (done) {
    var vm = new _vue2.default({
      data: {
        test: 'foo'
      },
      template: '<input v-model="test">'
    }).$mount();
    var input = vm.$el;
    triggerEvent(input, 'compositionstart');
    input.value = 'baz';
    // input before composition unlock should not call set
    triggerEvent(input, 'input');
    expect(vm.test).toBe('foo');
    // after composition unlock it should work
    triggerEvent(input, 'compositionend');
    triggerEvent(input, 'input');
    expect(vm.test).toBe('baz');
    done();
  });

  it('warn invalid tag', function () {
    new _vue2.default({
      data: {
        test: 'foo'
      },
      template: '<div v-model="test"></div>'
    }).$mount();
    expect('<div v-model="test">: v-model is not supported on this element type').toHaveBeenWarned();
  });

  // #3468
  it('should have higher priority than user v-on events', function () {
    var spy = jasmine.createSpy();
    var vm = new _vue2.default({
      data: {
        a: 'a'
      },
      template: '<input v-model="a" @input="onInput">',
      methods: {
        onInput: function onInput(e) {
          spy(e.target.value);
        }
      }
    }).$mount();
    vm.$el.value = 'b';
    triggerEvent(vm.$el, 'input');
    expect(spy).toHaveBeenCalledWith('b');
  });

  it('warn binding to v-for alias', function () {
    new _vue2.default({
      data: {
        strings: ['hi']
      },
      template: '\n        <div>\n          <div v-for="str in strings">\n            <input v-model="str">\n          </div>\n        </div>\n      '
    }).$mount();
    expect('You are binding v-model directly to a v-for iteration alias').toHaveBeenWarned();
  });

  it('warn if v-model and v-bind:value conflict', function () {
    new _vue2.default({
      data: {
        test: 'foo'
      },
      template: '<input type="text" v-model="test" v-bind:value="test">'
    }).$mount();
    expect('v-bind:value="test" conflicts with v-model').toHaveBeenWarned();
  });

  it('warn if v-model and :value conflict', function () {
    new _vue2.default({
      data: {
        test: 'foo'
      },
      template: '<input type="text" v-model="test" :value="test">'
    }).$mount();
    expect(':value="test" conflicts with v-model').toHaveBeenWarned();
  });

  it('should not warn on radio, checkbox, or custom component', function () {
    new _vue2.default({
      data: { test: '' },
      components: {
        foo: {
          props: ['model', 'value'],
          model: { prop: 'model', event: 'change' },
          template: '<div/>'
        }
      },
      template: '\n        <div>\n          <input type="checkbox" v-model="test" :value="test">\n          <input type="radio" v-model="test" :value="test">\n          <foo v-model="test" :value="test"/>\n        </div>\n      '
    }).$mount();
    expect('conflicts with v-model').not.toHaveBeenWarned();
  });

  it('should not warn on input with dynamic type binding', function () {
    new _vue2.default({
      data: {
        type: 'checkbox',
        test: 'foo'
      },
      template: '<input :type="type" v-model="test" :value="test">'
    }).$mount();
    expect('conflicts with v-model').not.toHaveBeenWarned();
  });

  if (!_env.isAndroid) {
    it('does not trigger extra input events with single compositionend', function () {
      var spy = jasmine.createSpy();
      var vm = new _vue2.default({
        data: {
          a: 'a'
        },
        template: '<input v-model="a" @input="onInput">',
        methods: {
          onInput: function onInput(e) {
            spy(e.target.value);
          }
        }
      }).$mount();
      expect(spy.calls.count()).toBe(0);
      vm.$el.value = 'b';
      triggerEvent(vm.$el, 'input');
      expect(spy.calls.count()).toBe(1);
      triggerEvent(vm.$el, 'compositionend');
      expect(spy.calls.count()).toBe(1);
    });

    it('triggers extra input on compositionstart + end', function () {
      var spy = jasmine.createSpy();
      var vm = new _vue2.default({
        data: {
          a: 'a'
        },
        template: '<input v-model="a" @input="onInput">',
        methods: {
          onInput: function onInput(e) {
            spy(e.target.value);
          }
        }
      }).$mount();
      expect(spy.calls.count()).toBe(0);
      vm.$el.value = 'b';
      triggerEvent(vm.$el, 'input');
      expect(spy.calls.count()).toBe(1);
      triggerEvent(vm.$el, 'compositionstart');
      triggerEvent(vm.$el, 'compositionend');
      expect(spy.calls.count()).toBe(2);
    });

    // #4392
    it('should not update value with modifiers when in focus if post-conversion values are the same', function (done) {
      var vm = new _vue2.default({
        data: {
          a: 1,
          foo: false
        },
        template: '<div>{{ foo }}<input ref="input" v-model.number="a"></div>'
      }).$mount();

      document.body.appendChild(vm.$el);
      vm.$refs.input.focus();
      vm.$refs.input.value = '1.000';
      vm.foo = true;

      waitForUpdate(function () {
        expect(vm.$refs.input.value).toBe('1.000');
      }).then(done);
    });

    // #6552
    // This was original introduced due to the microtask between DOM events issue
    // but fixed after switching to MessageChannel.
    it('should not block input when another input listener with modifier is used', function (done) {
      var vm = new _vue2.default({
        data: {
          a: 'a',
          foo: false
        },
        template: '\n          <div>\n            <input ref="input" v-model="a" @input.capture="onInput">{{ a }}\n            <div v-if="foo">foo</div>\n          </div>\n        ',
        methods: {
          onInput: function onInput(e) {
            this.foo = true;
          }
        }
      }).$mount();

      document.body.appendChild(vm.$el);
      vm.$refs.input.focus();
      vm.$refs.input.value = 'b';
      triggerEvent(vm.$refs.input, 'input');

      // not using wait for update here because there will be two update cycles
      // one caused by onInput in the first listener
      setTimeout(function () {
        expect(vm.a).toBe('b');
        expect(vm.$refs.input.value).toBe('b');
        done();
      }, 16);
    });

    it('should create and make reactive non-existent properties', function (done) {
      var vm = new _vue2.default({
        data: {
          foo: {}
        },
        template: '<input v-model="foo.bar">'
      }).$mount();
      expect(vm.$el.value).toBe('');

      vm.$el.value = 'a';
      triggerEvent(vm.$el, 'input');
      expect(vm.foo.bar).toBe('a');
      vm.foo.bar = 'b';
      waitForUpdate(function () {
        expect(vm.$el.value).toBe('b');
        vm.foo = {};
      }).then(function () {
        expect(vm.$el.value).toBe('');
      }).then(done);
    });
  }

  // #7138
  if (_env.isIE && !_env.isIE9) {
    it('should not fire input on initial render of textarea with placeholder in IE10/11', function (done) {
      var el = document.createElement('div');
      document.body.appendChild(el);
      var vm = new _vue2.default({
        el: el,
        data: { foo: null },
        template: '<textarea v-model="foo" placeholder="bar"></textarea>'
      });
      setTimeout(function () {
        expect(vm.foo).toBe(null);
        done();
      }, 17);
    });
  }
});

