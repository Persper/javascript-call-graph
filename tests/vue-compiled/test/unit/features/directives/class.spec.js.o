'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _vue = require('vue');

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assertClass(assertions, done) {
  var vm = new _vue2.default({
    template: '<div class="foo" :class="value"></div>',
    data: { value: '' }
  }).$mount();
  var chain = waitForUpdate();
  assertions.forEach(function (_ref, i) {
    var _ref2 = _slicedToArray(_ref, 2),
        value = _ref2[0],
        expected = _ref2[1];

    chain.then(function () {
      if (typeof value === 'function') {
        value(vm.value);
      } else {
        vm.value = value;
      }
    }).then(function () {
      expect(vm.$el.className).toBe(expected);
      if (i >= assertions.length - 1) {
        done();
      }
    });
  });
  chain.then(done);
}

describe('Directive v-bind:class', function () {
  it('plain string', function (done) {
    assertClass([['bar', 'foo bar'], ['baz qux', 'foo baz qux'], ['qux', 'foo qux'], [undefined, 'foo']], done);
  });

  it('object value', function (done) {
    assertClass([[{ bar: true, baz: false }, 'foo bar'], [{ baz: true }, 'foo baz'], [null, 'foo'], [{ 'bar baz': true, qux: false }, 'foo bar baz'], [{ qux: true }, 'foo qux']], done);
  });

  it('array value', function (done) {
    assertClass([[['bar', 'baz'], 'foo bar baz'], [['qux', 'baz'], 'foo qux baz'], [['w', 'x y z'], 'foo w x y z'], [undefined, 'foo'], [['bar'], 'foo bar'], [function (val) {
      return val.push('baz');
    }, 'foo bar baz']], done);
  });

  it('array of mixed values', function (done) {
    assertClass([[['x', { y: true, z: true }], 'foo x y z'], [['x', { y: true, z: false }], 'foo x y'], [['f', { z: true }], 'foo f z'], [['l', 'f', { n: true, z: true }], 'foo l f n z'], [['x', {}], 'foo x'], [undefined, 'foo']], done);
  });

  it('class merge between parent and child', function (done) {
    var vm = new _vue2.default({
      template: '<child class="a" :class="value"></child>',
      data: { value: 'b' },
      components: {
        child: {
          template: '<div class="c" :class="value"></div>',
          data: function data() {
            return { value: 'd' };
          }
        }
      }
    }).$mount();
    var child = vm.$children[0];
    expect(vm.$el.className).toBe('c a d b');
    vm.value = 'e';
    waitForUpdate(function () {
      expect(vm.$el.className).toBe('c a d e');
    }).then(function () {
      child.value = 'f';
    }).then(function () {
      expect(vm.$el.className).toBe('c a f e');
    }).then(function () {
      vm.value = { foo: true };
      child.value = ['bar', 'baz'];
    }).then(function () {
      expect(vm.$el.className).toBe('c a bar baz foo');
    }).then(done);
  });

  it('class merge between multiple nested components sharing same element', function (done) {
    var vm = new _vue2.default({
      template: '\n        <component1 :class="componentClass1">\n          <component2 :class="componentClass2">\n            <component3 :class="componentClass3">\n              some text\n            </component3>\n          </component2>\n        </component1>\n      ',
      data: {
        componentClass1: 'componentClass1',
        componentClass2: 'componentClass2',
        componentClass3: 'componentClass3'
      },
      components: {
        component1: {
          render: function render() {
            return this.$slots.default[0];
          }
        },
        component2: {
          render: function render() {
            return this.$slots.default[0];
          }
        },
        component3: {
          template: '<div class="staticClass"><slot></slot></div>'
        }
      }
    }).$mount();
    expect(vm.$el.className).toBe('staticClass componentClass3 componentClass2 componentClass1');
    vm.componentClass1 = 'c1';
    waitForUpdate(function () {
      expect(vm.$el.className).toBe('staticClass componentClass3 componentClass2 c1');
      vm.componentClass2 = 'c2';
    }).then(function () {
      expect(vm.$el.className).toBe('staticClass componentClass3 c2 c1');
      vm.componentClass3 = 'c3';
    }).then(function () {
      expect(vm.$el.className).toBe('staticClass c3 c2 c1');
    }).then(done);
  });

  it('deep update', function (done) {
    var vm = new _vue2.default({
      template: '<div :class="test"></div>',
      data: {
        test: { a: true, b: false }
      }
    }).$mount();
    expect(vm.$el.className).toBe('a');
    vm.test.b = true;
    waitForUpdate(function () {
      expect(vm.$el.className).toBe('a b');
    }).then(done);
  });

  // a vdom patch edge case where the user has several un-keyed elements of the
  // same tag next to each other, and toggling them.
  it('properly remove staticClass for toggling un-keyed children', function (done) {
    var vm = new _vue2.default({
      template: '\n        <div>\n          <div v-if="ok" class="a"></div>\n          <div v-if="!ok"></div>\n        </div>\n      ',
      data: {
        ok: true
      }
    }).$mount();
    expect(vm.$el.children[0].className).toBe('a');
    vm.ok = false;
    waitForUpdate(function () {
      expect(vm.$el.children[0].className).toBe('');
    }).then(done);
  });
});

