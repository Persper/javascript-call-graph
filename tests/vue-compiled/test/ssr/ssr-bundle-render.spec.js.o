'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderer = createRenderer;

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

var _compileWithWebpack = require('./compile-with-webpack');

var _vueServerRenderer = require('../../packages/vue-server-renderer');

var _serverPlugin = require('../../packages/vue-server-renderer/server-plugin');

var _serverPlugin2 = _interopRequireDefault(_serverPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createRenderer(file, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = undefined;
  }
  var asBundle = !!(options && options.asBundle);
  if (options) delete options.asBundle;

  (0, _compileWithWebpack.compileWithWebpack)(file, {
    target: 'node',
    devtool: asBundle ? '#source-map' : false,
    output: {
      path: '/',
      filename: 'bundle.js',
      libraryTarget: 'commonjs2'
    },
    externals: [require.resolve('../../dist/vue.runtime.common.js')],
    plugins: asBundle ? [new _serverPlugin2.default()] : []
  }, function (fs) {
    var bundle = asBundle ? JSON.parse(fs.readFileSync('/vue-ssr-server-bundle.json', 'utf-8')) : fs.readFileSync('/bundle.js', 'utf-8');
    var renderer = (0, _vueServerRenderer.createBundleRenderer)(bundle, options);
    cb(renderer);
  });
}

describe('SSR: bundle renderer', function () {
  createAssertions(true);
  createAssertions(false);
});

function createAssertions(runInNewContext) {
  it('renderToString', function (done) {
    createRenderer('app.js', { runInNewContext: runInNewContext }, function (renderer) {
      var context = { url: '/test' };
      renderer.renderToString(context, function (err, res) {
        expect(err).toBeNull();
        expect(res).toBe('<div data-server-rendered="true">/test</div>');
        expect(context.msg).toBe('hello');
        done();
      });
    });
  });

  it('renderToStream', function (done) {
    createRenderer('app.js', { runInNewContext: runInNewContext }, function (renderer) {
      var context = { url: '/test' };
      var stream = renderer.renderToStream(context);
      var res = '';
      stream.on('data', function (chunk) {
        res += chunk.toString();
      });
      stream.on('end', function () {
        expect(res).toBe('<div data-server-rendered="true">/test</div>');
        expect(context.msg).toBe('hello');
        done();
      });
    });
  });

  it('renderToString catch error', function (done) {
    createRenderer('error.js', { runInNewContext: runInNewContext }, function (renderer) {
      renderer.renderToString(function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToString catch Promise rejection', function (done) {
    createRenderer('promise-rejection.js', { runInNewContext: runInNewContext }, function (renderer) {
      renderer.renderToString(function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToStream catch error', function (done) {
    createRenderer('error.js', { runInNewContext: runInNewContext }, function (renderer) {
      var stream = renderer.renderToStream();
      stream.on('error', function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToStream catch Promise rejection', function (done) {
    createRenderer('promise-rejection.js', { runInNewContext: runInNewContext }, function (renderer) {
      var stream = renderer.renderToStream();
      stream.on('error', function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('render with cache (get/set)', function (done) {
    var cache = {};
    var _get = jasmine.createSpy('get');
    var _set = jasmine.createSpy('set');
    var options = {
      runInNewContext: runInNewContext,
      cache: {
        // async
        get: function get(key, cb) {
          setTimeout(function () {
            _get(key);
            cb(cache[key]);
          }, 0);
        },
        set: function set(key, val) {
          _set(key, val);
          cache[key] = val;
        }
      }
    };
    createRenderer('cache.js', options, function (renderer) {
      var expected = '<div data-server-rendered="true">/test</div>';
      var key = 'app::1';
      renderer.renderToString(function (err, res) {
        expect(err).toBeNull();
        expect(res).toBe(expected);
        expect(_get).toHaveBeenCalledWith(key);
        var setArgs = _set.calls.argsFor(0);
        expect(setArgs[0]).toBe(key);
        expect(setArgs[1].html).toBe(expected);
        expect(cache[key].html).toBe(expected);
        renderer.renderToString(function (err, res) {
          expect(err).toBeNull();
          expect(res).toBe(expected);
          expect(_get.calls.count()).toBe(2);
          expect(_set.calls.count()).toBe(1);
          done();
        });
      });
    });
  });

  it('render with cache (get/set/has)', function (done) {
    var cache = {};
    var _has = jasmine.createSpy('has');
    var _get2 = jasmine.createSpy('get');
    var _set2 = jasmine.createSpy('set');
    var options = {
      runInNewContext: runInNewContext,
      cache: {
        // async
        has: function has(key, cb) {
          _has(key);
          cb(!!cache[key]);
        },
        // sync
        get: function get(key) {
          _get2(key);
          return cache[key];
        },
        set: function set(key, val) {
          _set2(key, val);
          cache[key] = val;
        }
      }
    };
    createRenderer('cache.js', options, function (renderer) {
      var expected = '<div data-server-rendered="true">/test</div>';
      var key = 'app::1';
      renderer.renderToString(function (err, res) {
        expect(err).toBeNull();
        expect(res).toBe(expected);
        expect(_has).toHaveBeenCalledWith(key);
        expect(_get2).not.toHaveBeenCalled();
        var setArgs = _set2.calls.argsFor(0);
        expect(setArgs[0]).toBe(key);
        expect(setArgs[1].html).toBe(expected);
        expect(cache[key].html).toBe(expected);
        renderer.renderToString(function (err, res) {
          expect(err).toBeNull();
          expect(res).toBe(expected);
          expect(_has.calls.count()).toBe(2);
          expect(_get2.calls.count()).toBe(1);
          expect(_set2.calls.count()).toBe(1);
          done();
        });
      });
    });
  });

  it('render with cache (nested)', function (done) {
    var cache = (0, _lruCache2.default)({ maxAge: Infinity });
    spyOn(cache, 'get').and.callThrough();
    spyOn(cache, 'set').and.callThrough();
    var options = {
      cache: cache,
      runInNewContext: runInNewContext
    };
    createRenderer('nested-cache.js', options, function (renderer) {
      var expected = '<div data-server-rendered="true">/test</div>';
      var key = 'app::1';
      var context1 = { registered: [] };
      var context2 = { registered: [] };
      renderer.renderToString(context1, function (err, res) {
        expect(err).toBeNull();
        expect(res).toBe(expected);
        expect(cache.set.calls.count()).toBe(3); // 3 nested components cached
        var cached = cache.get(key);
        expect(cached.html).toBe(expected);
        expect(cache.get.calls.count()).toBe(1);

        // assert component usage registration for nested children
        expect(context1.registered).toEqual(['app', 'child', 'grandchild']);

        renderer.renderToString(context2, function (err, res) {
          expect(err).toBeNull();
          expect(res).toBe(expected);
          expect(cache.set.calls.count()).toBe(3); // no new cache sets
          expect(cache.get.calls.count()).toBe(2); // 1 get for root

          expect(context2.registered).toEqual(['app', 'child', 'grandchild']);
          done();
        });
      });
    });
  });

  it('renderToString (bundle format with code split)', function (done) {
    createRenderer('split.js', { runInNewContext: runInNewContext, asBundle: true }, function (renderer) {
      var context = { url: '/test' };
      renderer.renderToString(context, function (err, res) {
        expect(err).toBeNull();
        expect(res).toBe('<div data-server-rendered="true">/test<div>async test.woff2 test.png</div></div>');
        done();
      });
    });
  });

  it('renderToStream (bundle format with code split)', function (done) {
    createRenderer('split.js', { runInNewContext: runInNewContext, asBundle: true }, function (renderer) {
      var context = { url: '/test' };
      var stream = renderer.renderToStream(context);
      var res = '';
      stream.on('data', function (chunk) {
        res += chunk.toString();
      });
      stream.on('end', function () {
        expect(res).toBe('<div data-server-rendered="true">/test<div>async test.woff2 test.png</div></div>');
        done();
      });
    });
  });

  it('renderToString catch error (bundle format with source map)', function (done) {
    createRenderer('error.js', { runInNewContext: runInNewContext, asBundle: true }, function (renderer) {
      renderer.renderToString(function (err) {
        expect(err.stack).toContain('test/ssr/fixtures/error.js:1:6');
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToString catch error (bundle format with source map)', function (done) {
    createRenderer('error.js', { runInNewContext: runInNewContext, asBundle: true }, function (renderer) {
      var stream = renderer.renderToStream();
      stream.on('error', function (err) {
        expect(err.stack).toContain('test/ssr/fixtures/error.js:1:6');
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToString return Promise', function (done) {
    createRenderer('app.js', { runInNewContext: runInNewContext }, function (renderer) {
      var context = { url: '/test' };
      renderer.renderToString(context).then(function (res) {
        expect(res).toBe('<div data-server-rendered="true">/test</div>');
        expect(context.msg).toBe('hello');
        done();
      });
    });
  });

  it('renderToString return Promise (error)', function (done) {
    createRenderer('error.js', { runInNewContext: runInNewContext }, function (renderer) {
      renderer.renderToString().catch(function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });

  it('renderToString return Promise (Promise rejection)', function (done) {
    createRenderer('promise-rejection.js', { runInNewContext: runInNewContext }, function (renderer) {
      renderer.renderToString().catch(function (err) {
        expect(err.message).toBe('foo');
        done();
      });
    });
  });
}

